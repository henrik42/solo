<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>From Zero To Hero</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Solo</span> <span class="project-version">0.1.0-SNAPSHOT</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1 "><a href="intro.html"><div class="inner"><span>Introduction to solo</span></div></a></li><li class="depth-1  current"><a href="README.html"><div class="inner"><span>From Zero To Hero</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>solo</span></div></div></li><li class="depth-2 branch"><a href="solo.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-2"><a href="solo.jumpstart.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>jumpstart</span></div></a></li><li class="depth-3"><a href="solo.jumpstart.servlet_container_initializer.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>servlet_container_initializer</span></div></a></li><li class="depth-2 branch"><a href="solo.nrepl.html"><div class="inner"><span class="tree" style="top: -52px;"><span class="top" style="height: 61px;"></span><span class="bottom"></span></span><span>nrepl</span></div></a></li><li class="depth-2"><a href="solo.swank.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>swank</span></div></a></li></ul></div><div class="document" id="content"><div class="doc"><div class="markdown"><hr />
<h1><a href="#from-zero-to-hero" name="from-zero-to-hero"></a>From Zero To Hero</h1>
<hr />
<p>This is a Clojure <a href="https://clojure.org/">https://clojure.org/</a> / ClojureScript <a href="https://clojurescript.org/">https://clojurescript.org/</a> tutorial.</p>
<p>We will build an application (_Solo_ [1]) that lets you control log4j [2] log-levels at runtime. <em>Solo</em> has a browser-based frontend (ClojureScript/JavaScript) and a backend running in the JVM (Clojure).</p>
<p>You can <em>mix</em> <em>Solo’s</em> backend with other JVM-applications (I’m targeting Java applications running in Wildfly/JBoss and Websphere) so that you can change logging configuration at runtime which is a nice feature for test, QA and production (many logging libraries and JEE servers support JMX [3] for this use-case [4], IBM Websphere has dynamic control over logging built in).</p>
<p>This tutorial is ment as a starter for people with little Clojure background. It will not explain/teach Clojure (you can find many good tutorials on THE NET) but show which libraries and tools are used to build and run the application.</p>
<p>[1] <a href="https://github.com/henrik42/solo">https://github.com/henrik42/solo</a><br />[2] <a href="https://logging.apache.org/log4j/1.2/">https://logging.apache.org/log4j/1.2/</a><br />[3] <a href="http://www.oracle.com/technetwork/articles/java/javamanagement-140525.html">http://www.oracle.com/technetwork/articles/java/javamanagement-140525.html</a><br />[4] <a href="https://logging.apache.org/log4j/2.0/manual/jmx.html">https://logging.apache.org/log4j/2.0/manual/jmx.html</a> </p>
<hr />
<h1><a href="#step-zero-just-clojure" name="step-zero-just-clojure"></a>Step Zero: Just Clojure</h1>
<hr />
<p>You can try all of the following examples from the git <code>master</code> branch. If you want to see how the workspace evolves from one step to the next you can <code>git clone</code> the repo and checkout the branches for each step – like so (assuming you checked out the repo to <code>solo-project/</code>):</p>
<pre><code>solo-project$ git checkout step-zero
Switched to branch 'step-zero'
</code></pre>
<p>For our first Clojure program we just need Java 1.8 JDK [1] and a Clojure 1.8.x JAR. Download Clojure 1.8.0 [2] into <code>solo-project/lib/clojure-1.8.0.jar</code> and execute:</p>
<pre><code>solo-project$ java -cp lib/\* clojure.main -e '(println "Hello, Clojure")'
Hello, Clojure
</code></pre>
<p>Here we’re executing the Clojure code from command line arguments.</p>
<p>[1] <a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html">http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a><br />[2] <a href="https://repo1.maven.org/maven2/org/clojure/clojure/1.8.0/clojure-1.8.0.jar">https://repo1.maven.org/maven2/org/clojure/clojure/1.8.0/clojure-1.8.0.jar</a> </p>
<hr />
<h1><a href="#step-one-log4j-solo-core" name="step-one-log4j-solo-core"></a>Step One: log4j, solo.core</h1>
<hr />
<p>Now we’re ready to implement the <em>core logic</em> of <em>Solo</em>.</p>
<p>First download <code>log4j-1.2.17.jar</code> [1] to <code>solo-project/lib/log4j-1.2.17.jar</code>.</p>
<p>Next create <code>solo-project/src/clj/solo</code>:</p>
<pre><code>solo-project$ mkdir -p src/clj/solo
</code></pre>
<p>All this has already been done for you in branch <code>step-one</code>.</p>
<p>There are just a few functions in <code>solo-project/src/clj/solo/core.clj</code> for retrieving the current log4j loggers and for setting the log-level of a logger. That’s all we need.</p>
<p>This is the relevant part of the code:</p>
<pre><code>(ns solo.core
  (:import [org.apache.log4j Logger Level]))

(defn logger-&gt;map [log4j-logger]
  {:logger-name (.getName log4j-logger)
   :log-level (-&gt; log4j-logger .getLevel str)})

(defn get-logger [logger-name]
  (-&gt; (Logger/getLogger logger-name)
      logger-&gt;map))

(defn set-log-level! [logger-name log-level]
  (-&gt; (Logger/getLogger logger-name)
      (.setLevel (Level/toLevel log-level))))

(defn get-current-loggers []
  (map logger-&gt;map
       (-&gt; (Logger/getRootLogger)
           .getLoggerRepository
           .getCurrentLoggers
           enumeration-seq)))
</code></pre>
<p>And run it:</p>
<pre><code>solo-project$ java -cp lib/\*:src/clj clojure.main \
  -e "(use 'solo.core) (set-log-level! \"foo\" \"INFO\") (get-current-loggers)"
({:logger-name "foo", :log-level "INFO"})
</code></pre>
<p>Instead of running the code from command-line arguments you can execute any script file and put the code in there. For example, let’s put the following code into <code>solo-project/scripts/script-one.clj</code>:</p>
<pre><code>(use 'solo.core)
(set-log-level! "foo" "INFO")
(println (get-current-loggers))
</code></pre>
<p>And run:</p>
<pre><code>solo-project$ java -cp lib/\*:src/clj clojure.main scripts/script-one.clj
({:logger-name foo, :log-level INFO})
</code></pre>
<p>Note that executing a script only evaluates the script <em>forms</em> but does <strong>not</strong> <strong>print</strong> their values.</p>
<p>Try changing the last line to</p>
<pre><code>(get-current-loggers)
</code></pre>
<p>Now re-run the command from above. It won’t print anything. Now run this instead:</p>
<pre><code>solo-project$ java -cp lib/\*:src/clj clojure.main -e '(load-file "scripts/script-one.clj")'
({:logger-name "foo", :log-level "INFO"})
</code></pre>
<p>So <code>-e</code> prints the result of the <strong>last</strong> <strong>evaluated</strong> <em>form</em>.</p>
<p><strong>Note:</strong> Clojure <em>script files</em> and “regular” Clojure code look almost the same and they can basically contain the same forms. But you <strong>load</strong> them differently. Script files are loaded directly by reading in the source forms (via file-io or from a socket or from an in-memory <code>String</code>). <em>Namespaced</em> code is loaded via a classpath lookup for AOT-compiled code and sources (see “Step Four” below). Do not confuse the two.</p>
<p>[1] I’m using the old log4j 1.2 but you should be able to switch to 2.x <a href="http://central.maven.org/maven2/log4j/log4j/1.2.17/log4j-1.2.17.jar">http://central.maven.org/maven2/log4j/log4j/1.2.17/log4j-1.2.17.jar</a> </p>
<hr />
<h1><a href="#step-two-rlwrap-repl" name="step-two-rlwrap-repl"></a>Step Two: rlwrap, REPL</h1>
<hr />
<p>Clojure is a <strong>compiled</strong> language and still you can use the runtime environment interactively using the <em>REPL</em> <a href="read-eval-print-loop">1</a>. The Clojure <em>forms</em> are compiled <em>just-in-time</em> while they are read from file/keyboard/etc (and there is also ahead-of-time/AOT [2] compilation).</p>
<p>When running on Linux it’s nice to use <code>rlwrap</code> [3]. This way you get <code>readline</code>-like (as in a <code>bash</code>) line-editing features (incl. command history).</p>
<pre><code>solo-project$ rlwrap java -cp lib/\*:src/clj clojure.main 
Clojure 1.8.0
user=&gt; (use 'solo.core)
nil
user=&gt; (set-log-level! "foo" "INFO")
nil
user=&gt; (get-current-loggers)
({:logger-name "foo", :log-level "INFO"})
user=&gt; ^D
</code></pre>
<p>If you change <code>solo/core.clj</code> after loading the namespace <code>solo.core</code> you can use <code>:reload</code> to see the changes in your REPL. So you need not restart your JVM and you do not lose your internal program state (i.e. any loggers you my have created):</p>
<pre><code>(use 'solo.core :reload)
</code></pre>
<p>More on REPL at <a href="https://clojure.org/guides/repl/introduction">https://clojure.org/guides/repl/introduction</a></p>
<p>[1] <a href="https://clojure.org/reference/repl_and_main">https://clojure.org/reference/repl_and_main</a><br />[2] <a href="https://clojure.org/reference/compilation">https://clojure.org/reference/compilation</a><br />[3] <a href="https://github.com/hanslub42/rlwrap">https://github.com/hanslub42/rlwrap</a> </p>
<hr />
<h1><a href="#step-three-swank-emacs-slime" name="step-three-swank-emacs-slime"></a>Step Three: Swank, Emacs/SLIME</h1>
<hr />
<p>We want to use an editor to edit the code and to evaluate our changes without starting the JVM over and over again each time we change our code. You can do this by reloading the code as shown in step two.</p>
<p>Another way to do this is to connect Emacs/SLIME [1] to the running JVM via <em>Swank</em> [2] (eventhough it’s deprecated). Download <code>swank-clojure-1.4.3.jar</code> [3] and <code>clj-stacktrace-0.2.4.jar</code> [4] to <code>solo-project/lib/</code>.</p>
<p>First we start the <em>Swank</em> server.</p>
<pre><code>solo-project$ java -cp lib/\*:src/clj clojure.main -m swank.swank 4005
</code></pre>
<p>Now connect from Emacs.</p>
<p>If you like to use Emacs/SLIME <strong>and</strong> have a REPL prompt at the same time, try this:</p>
<pre><code>solo-project$ rlwrap java -cp lib/\*:src/clj clojure.main \
  -e "(use 'swank.swank) (start-server :host \"0.0.0.0\" :port 4005)" \
  -r
Connection opened on 0.0.0.0 port 4005.
user=&gt; 
</code></pre>
<p>I’m using host/IP <code>0.0.0.0</code> so that you can run this on some Linux server in your office network and connect to the Swank server from your desktop PC running Emacs/SLIME (if we were using <code>127.0.0.1</code> you couldn’t connect from any remote host).</p>
<p><strong>WARNING:</strong> Note that <strong>anyone</strong> can connect to the JVM from any host  that can reach your host (via a TCP/IP route) and thus has full  control over the running JVM. So do this only on <strong>trusted</strong>  <strong>networks</strong>!</p>
<p>If you’re running Emacs and Clojure/JVM on the <strong>same</strong> <strong>machine</strong>  you should use <code>127.0.0.1</code> (do <strong>not</strong> use <code>localhost</code> since you  cannot be sure which IP it is mapped to on hosts that you do not  control!) instead of <code>0.0.0.0</code>. Use <code>127.0.0.1</code> together with an SSL  tunnel to remotely connect from a <strong>trusted</strong> <strong>host</strong> running  Emacs/SLIME to the <strong>trusted</strong> <strong>host</strong> running Clojure over an  <strong>untrusted</strong> network.</p>
<p>Finally we can put the code into <code>src/clj/solo/swank.clj</code> for re-use:</p>
<pre><code>(ns solo.swank
  (require [swank.swank :as swank]))

(defn -main [&amp; args]
  (let [{:keys [host port] :or {host "0.0.0.0" port 4005}}
        (map (comp read-string str) args)]
    (swank/start-server :port port :host host)))
</code></pre>
<p>The <code>-main</code> function is (by convention) special – it can be run like this (note that it will receive <code>String</code>-type arguments when called from command-line)</p>
<pre><code>solo-project$ rlwrap java -cp lib/\*:src/clj clojure.main -m solo.swank :port 4006
Connection opened on 0.0.0.0 port 4006.
</code></pre>
<p>If you want the REPL also you can do this (here we’re loading <code>swank.clj</code> as a script):</p>
<pre><code>solo-project$ rlwrap java -cp lib/\*:src/clj clojure.main -i src/clj/solo/swank.clj -e "(solo.swank/-main)" -r
Connection opened on 0.0.0.0 port 4005.
user=&gt; 
</code></pre>
<p>Now you can use the <strong>REPL</strong> <strong>and/or</strong> <strong>Emacs</strong> to evaluate code and to reload changes you make to <code>core.clj</code> and switch back and forth between them.</p>
<p>[1] <a href="https://common-lisp.net/project/slime/">https://common-lisp.net/project/slime/</a><br />[2] <a href="https://github.com/technomancy/swank-clojure">https://github.com/technomancy/swank-clojure</a><br />[3] <a href="https://repo.clojars.org/swank-clojure/swank-clojure/1.4.3/swank-clojure-1.4.3.jar">https://repo.clojars.org/swank-clojure/swank-clojure/1.4.3/swank-clojure-1.4.3.jar</a><br />[4] <a href="https://repo.clojars.org/clj-stacktrace/clj-stacktrace/0.2.4/clj-stacktrace-0.2.4.jar">https://repo.clojars.org/clj-stacktrace/clj-stacktrace/0.2.4/clj-stacktrace-0.2.4.jar</a> </p>
<hr />
<h1><a href="#step-four-containers-solo-jumpstart" name="step-four-containers-solo-jumpstart"></a>Step Four: Containers, solo.jumpstart</h1>
<hr />
<p>We want to use <em>Solo</em> within a <em>host application</em> – i.e. a Java application that does not offer changing log4j log-levels at runtime out-of-the-box. We want to hook <em>Solo</em> into this application changing as little as possible about its configuration.</p>
<p>When you’re working in a Java-shop you may be using JEE application servers (like JBoss, Wildfly, IBM Websphere) or other containers (like Tomcat, Jetty, Spring Boot). Usually the applications that run in these containers will be Java applications with no Clojure included. These applications do not know about Clojure or <em>Solo</em> and they probably have no built-in way of executing arbitrary code/classes. So in order to run <em>Solo</em>, we somehow have to gain control over an execution thread … the host application has to <em>jump-start</em> <em>Solo</em> (implicitly).</p>
<p>There are many things going on in typical Java applications that let you gain control to have you jump-started:</p>
<ul>
  <li>
  <p><strong>Context Dependency Injection</strong>: CDI [1a, 1b] (and SPI [2a, 2b]  architectures in general) lets you <em>extend</em> the functionality of a  CDI implementation.</p></li>
  <li>
  <p><strong>Java Server Faces</strong>: JSF [3] has ways to supply and discover  <em>managed beans</em>. So you can use this mechanism to make the JSF  runtime call your code.</p></li>
  <li>
  <p><strong>Spring IoC</strong>: Spring [4] lets you define Spring beans that can run  your code.</p></li>
  <li>
  <p><strong>log4j</strong>: log4j [5] lets you name and load <code>Logger</code> implementations  and you can supply yours. When its class gets loaded you can run  your code.</p></li>
  <li>
  <p><strong>JDK Resource Bundle</strong>: <code>ResourceBundle</code> [6] has a class-loading  mechanism, so if you can make the host-application load a specific  <code>ResourceBundle</code>, it will execute your code.</p></li>
</ul>
<p>There are more things you can do:</p>
<ul>
  <li>
  <p><strong>deploy an EJB</strong>: package an EJB with our code and deploy that (and  the libs) into your JEE server. Your EJB will be instantiated so you  can do what you need to. You can even use JEE-annotations for  Clojure-generated classes.</p></li>
  <li>
  <p><strong>deploy a WAR</strong>: package a WAR (incl. the libs), which you can then  deploy to JEE containers as well as servlet containers. This way you  can deliver a servlet which again will be initialized and run.</p></li>
  <li>
  <p><strong>deploy a JAR</strong>: package a JAR, which contains some/any of the  artifacts mentioned above.</p></li>
</ul>
<p>All of these <strong>frameworks</strong> (except Spring) have one in common: you have to deliver a <strong>named class</strong> for them to call your code. You cannot just deliver Clojure source code and let the framework reflectively call <code>clojure.lang.RT.load(&lt;your-namespace&gt;)</code>. Some of them let you supply annotated classes which are then picked up by the framework via classpath scanning.</p>
<p>So we have to use <code>gen-class</code> to deliver that class. This class is just used for <strong>loading</strong> your namespace! It need not include the Clojure code you want to execute. So we can deliver an <em>empty</em> compiled namespace, package that in a JAR (or just put it on the classpath) and then supply the <em>real</em> code seperatly (see below).</p>
<p>But it does not suffice to just deliver the classes for your jumpstart-namespace. You also have to deliver the JARs under <code>solo-project/lib/</code> so you can use them (except – probably – log4j). At this point you have to understand how classloaders work and how the mentioned frameworks organize the classloaders they use.</p>
<p>In many cases your class will be loaded by a classloader that has no access (neither direct nor by delegation to other <em>co-laborating</em> classloaders) to the host application’s classes (incl. log4j). Often the jumpstart-class does not even <em>see</em> the Clojure runtime-classes eventhough you supplied the libs. This usually leads to <code>ClassNotFoundException</code> and then <code>NoClassDefFoundException</code> when loading your jumpstart-namespace. You find examples/solutions for this below.</p>
<p>[1a] <a href="https://docs.jboss.org/cdi/spec/1.0/html/">https://docs.jboss.org/cdi/spec/1.0/html/</a> [1b] <a href="https://jaxenter.com/tutorial-introduction-to-cdi-contexts-and-dependency-injection-for-java-ee-jsr-299-104536.html">https://jaxenter.com/tutorial-introduction-to-cdi-contexts-and-dependency-injection-for-java-ee-jsr-299-104536.html</a><br />[2a] <a href="https://docs.oracle.com/javase/tutorial/sound/SPI-intro.html">https://docs.oracle.com/javase/tutorial/sound/SPI-intro.html</a><br />[2b] <a href="https://docs.oracle.com/javase/tutorial/ext/basics/spi.html">https://docs.oracle.com/javase/tutorial/ext/basics/spi.html</a><br />[3] <a href="http://www.oracle.com/technetwork/java/javaee/javaserverfaces-139869.html">http://www.oracle.com/technetwork/java/javaee/javaserverfaces-139869.html</a><br />[4] <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html">https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html</a><br />[5] <a href="https://logging.apache.org/log4j/1.2/">https://logging.apache.org/log4j/1.2/</a><br />[6] <a href="https://docs.oracle.com/javase/8/docs/api/java/util/ResourceBundle.html">https://docs.oracle.com/javase/8/docs/api/java/util/ResourceBundle.html</a> </p>
<h2><a href="#solo-jumpstart-jsf" name="solo-jumpstart-jsf"></a>solo.jumpstart.jsf</h2>
<p>Here we jump-start <em>Solo</em> via a Java Server Faces <em>managed</em> <em>bean</em>. You can use this in cases where your Java host application uses JSF.</p>
<p>There are several ways to supply a JSF bean. One is to deliver the file/resource <code>META-INF/faces-config.xml</code> which contains the bean definition with the <em>named class</em>. This is <code>jumpstart/resources/META-INF/faces-config.xml</code>:</p>
<pre><code>&lt;faces-config xmlns="http://java.sun.com/xml/ns/javaee" 
              xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
              xsi:schemaLocation="http://java.sun.com/xml/ns/javaee 
                                  http://java.sun.com/xml/ns/javaee/web-facesconfig_1_2.xsd" 
              version="1.2"&gt; 
  &lt;managed-bean&gt;
    &lt;managed-bean-name&gt;jumpstart&lt;/managed-bean-name&gt;
    &lt;managed-bean-class&gt;solo.jumpstart.jsf&lt;/managed-bean-class&gt;
    &lt;managed-bean-scope&gt;application&lt;/managed-bean-scope&gt;
  &lt;/managed-bean&gt;
&lt;/faces-config&gt;
</code></pre>
<p>JSF will try to load/instanciate the class <code>solo.jumpstart.jsf</code> in this case. So we have to deliver such a <em>named class</em>. In Clojure you use <code>gen-class</code> and <em>Ahead-of-Time-Compilation</em> (AOT) to create the class file <code>solo/jumpstart/jsf.class</code>.</p>
<p>For reference – here’s the Clojure code <code>solo-project/jumpstart/src/solo/jumpstart/jsf.clj</code>:</p>
<pre><code>(ns solo.jumpstart.jsf
  (:gen-class
   :init init))

(defn -init []
  (println "solo.jumpstart.jsf/-init")
  [[]])

(defn -main [&amp; args]
  (println (str "solo.jumpstart.jsf/-main: " args))
  (solo.jumpstart.jsf.))
</code></pre>
<p>That’s not much :) This code does almost <strong>nothing</strong> (but see below).</p>
<p>For compile &amp; package you can use <code>/scripts/make-jumpstart-jsf.sh</code>:</p>
<pre><code>#!/bin/bash -ex

mkdir -p classes/
rm -rf classes/*
java -cp jumpstart/src/:classes/:lib/clojure-1.8.0.jar clojure.main -e "(compile 'solo.jumpstart.jsf)"
jar -vcf jumpstart-jsf.jar -C classes/ solo
jar -vuf jumpstart-jsf.jar -C jumpstart/resources/ META-INF
</code></pre>
<p>The JAR <code>jumpstart-jsf.jar</code> should look like this:</p>
<pre><code>solo-project$ jar -vtf jumpstart-jsf.jar 
    68 Thu Apr 05 19:04:56 UTC 2018 META-INF/MANIFEST.MF
     0 Thu Apr 05 19:03:20 UTC 2018 solo/
     0 Thu Apr 05 19:03:20 UTC 2018 solo/jumpstart/
  1338 Thu Apr 05 19:03:20 UTC 2018 solo/jumpstart/jsf$fn__5.class
  1516 Thu Apr 05 19:03:20 UTC 2018 solo/jumpstart/jsf$loading__5569__auto____3.class
   905 Thu Apr 05 19:03:20 UTC 2018 solo/jumpstart/jsf$_init.class
  2066 Thu Apr 05 19:03:20 UTC 2018 solo/jumpstart/jsf.class
  2477 Thu Apr 05 19:03:20 UTC 2018 solo/jumpstart/jsf__init.class
   565 Thu Apr 05 19:04:24 UTC 2018 META-INF/faces-config.xml
</code></pre>
<p>And you can run this class:</p>
<pre><code>solo-project$ java -cp jumpstart-jsf.jar:lib/clojure-1.8.0.jar solo.jumpstart.jsf foo bar
solo.jumpstart.jsf/-main: ("foo" "bar")
solo.jumpstart.jsf/-init
</code></pre>
<p>Some things to note:</p>
<ul>
  <li>
  <p>we don’t need <code>-main</code> for jump-starting <em>Solo</em> via JSF. It’s just  there so that <code>gen-class</code> generates the main-entry method <code>public
  static void main(String[])</code> for us so that we can run it from  command-line.</p></li>
  <li>
  <p>the generated class file <code>solo/jumpstart/jsf.class</code> does several  things: (1) it bootstraps the Clojure runtime (2) it loads the  namespace <code>solo.jumpstart.jsf</code>. The <strong>method</strong> <code>jsf/main</code> and the  (only) <strong>constructor</strong> <code>jsf()</code> delegate to the functions <code>-main</code> and  <code>-init</code> in namespace <code>solo.jumpstart.jsf</code>.</p></li>
  <li>
  <p>the classpath above did not include  <code>solo-project/jumpstart/src/</code>. So the compiled namespace  <code>solo.jumpstart.jsf</code> is <strong>included</strong> in the JAR. Still the Clojure  <em>loader</em> will search for the <strong>source</strong> <code>solo/jumpstart/jsf.clj</code>  when loading the namespace and only if it cannot find the source it  will use the compiled version.</p></li>
</ul>
<p>For <em>production</em> we want to use <code>jumpstart-jsf.jar</code> just for loading Clojure and delegation logic. The <em>real</em> logic that we want to have jump-started should come from a source folder that we put into the classpath and have that loaded.</p>
<p>So let’s try this: put your jump-start logic into <code>src/clj/solo/jumpstart/jsf.clj</code>:</p>
<pre><code>(ns solo.jumpstart.jsf
  (require [solo.swank :as swank]))

(defn -init []
  (println "solo.jumpstart.jsf/-init: starting Swank server")
  (swank/-main)
  (println "solo.jumpstart.jsf/-init: started Swank server")
  [[]])

(defn -main [&amp; args]
  (println (str "solo.jumpstart.jsf/-main: " args))
  (solo.jumpstart.jsf.))
</code></pre>
<p>This time we put <code>src/clj/</code> and all the libs into the classpath:</p>
<pre><code>solo-project$ java -cp jumpstart-jsf.jar:lib/*:src/clj/ solo.jumpstart.jsf foo bar
solo.jumpstart.jsf/-main: ("foo" "bar")
solo.jumpstart.jsf/-init: starting Swank server
Connection opened on 0.0.0.0 port 4005.
solo.jumpstart.jsf/-init: started Swank server
</code></pre>
<p>Cool!</p>
<p>Now we have it: we use the generated <em>named classes</em> just for loading a Clojure namespace and we supply the Clojure source code on the classpath (in a JAR and/or in a file-system folder).</p>
<p><strong>Wildfly/JBoss</strong></p>
<p>For JBoss and Wildfly you can <em>deploy</em> the JARs (incl. <code>jumpstart-faces.jar</code>) to the <em>content</em> <em>repository</em> and <em>assign</em> them to the server group of your server.</p>
<p>There is one problem: the module classloader that loads <code>jumpstart-faces.jar</code> does not <em>see</em> the assigned (module) <code>clojure-1.8.0.jar</code>! So you won’t be able to load <code>solo/jumpstart/faces.class</code>. You could fix this by tweaking the module’s dependencies.</p>
<p>I usually just create a <em>global</em> <em>module</em> at <code>&lt;jboss-root&gt;/module/jumpstart-faces/main/module.xml</code>:</p>
<p>So Clojure and the jumpstarter both are loaded by the same module classloader.</p>
<p>Now you have to configure the global module for your profile:</p>
<p><strong>TODO: Jump-start telnet server</strong></p>
<p><strong>TODO: jump-start swank</strong></p>
<hr />
<h1><a href="#step-five-nrepl" name="step-five-nrepl"></a>Step Five: nREPL</h1>
<hr />
<p>If you want to connect <strong>remotely</strong> via a <strong>REPL</strong> to a Clojure runtime you can use nREPL [1]. nREPL is a generic remote service (server and client) into a runnng Clojure runtime and is used for connecting REPLs, IDE integration and programmatic client calls.</p>
<p>Download [2] it to <code>solo-project/lib/tools.nrepl-0.2.13.jar</code>:</p>
<pre><code>solo-project/lib$ wget http://central.maven.org/maven2/org/clojure/tools.nrepl/0.2.13/tools.nrepl-0.2.13.jar
</code></pre>
<p>As with Swank we start the nREPL server and a REPL for local use (note that the socket is opened on <code>0.0.0.0</code> – see above!). </p>
<pre><code>solo-project$ rlwrap java -cp lib/\*:src/clj clojure.main -e "(use 'clojure.tools.nrepl.server) (start-server :port 7888)" -r
#clojure.tools.nrepl.server.Server{:server-socket ... "ServerSocket[addr=/0:0:0:0:0:0:0:0,localport=7888]"] ...
user=&gt; (use 'solo.core)                     
nil
</code></pre>
<p>Now you can connect from another running Clojure JVM (note that we do not add <code>src/clj</code> to the classpath), connect to the nREPL server and remote-eval some code:</p>
<pre><code>solo-project$ rlwrap java -cp lib/\* clojure.main
Clojure 1.8.0
user=&gt; (use 'clojure.tools.nrepl)
nil
user=&gt; (with-open [conn (connect :port 7888)] (-&gt; (client conn 1000) (message {:op :eval :code "(get-current-loggers)"}) response-values))
[()]
</code></pre>
<p>Now set the log-level in the nREPL-server JVM:</p>
<pre><code>user=&gt; (set-log-level! "foo" "INFO")
nil
</code></pre>
<p>And again in the nREPL-client JVM:</p>
<pre><code>user=&gt; (with-open [conn (connect :port 7888)]
  (-&gt; (client conn 1000) (message {:op :eval :code "(get-current-loggers)"})
  response-values))
[({:logger-name "foo", :log-level "INFO"})]
</code></pre>
<p>Since we will be using nREPL for <em>Solo</em> from now on, we use a separate namespace <code>solo.nrepl</code> in <code>solo/nrepl.clj</code> to put the related code there.</p>
<p>Besides directly using <code>clojure.tools.nrepl.client</code> there are other ways to connect to an nREPL server:</p>
<ul>
  <li>
  <p><strong>Counterclockwise</strong> [3]: an Eclipse Plugin for Clojure development</p></li>
  <li>
  <p><strong>Emacs/cider</strong> [4]: use cider/nREPL this instead of SLIME/Swank</p></li>
  <li>
  <p><strong>Leiningen</strong> [5]: a build tool (see next step)</p></li>
</ul>
<p><strong>Wildfly/JBoss</strong></p>
<p>Now we want to jump-start the nREPL server so we have remote access to the application.</p>
<p>Here again we cannot load the nREPL namespace because the classloader does not see the JAR/classes. One solution would be to also put the <code>tools.nrepl-0.2.13.jar</code> into the <strong>global</strong> <strong>module</strong> instead of <strong>assigning</strong> it.</p>
<p>An alternative is to use the thread <strong>context</strong> <strong>classloader</strong> (CCL) that is active when <code>solo/jumpstart/faces.class</code> is loaded to load nREPL. The CCL <em>sees</em> all (assigned and global) modules and all application JARs/EJBs.</p>
<p><strong>TODO: Geht das?</strong> Kann man damit nREPL laden und dann auch auf die Anwendungsklassen zugreifen. Man muss vorsichtig sein, weil eben clojure selbst über einen anderen classloader geladen wird als der ganze Rest.</p>
<p><strong>TODO:</strong> Wie verhält es sich mit Swank? Werden dort auch alle Klassen gesehen.</p>
<p><strong>Websphere</strong></p>
<p><strong>TODO:</strong> <a href="https://stackoverflow.com/questions/158336/is-there-a-way-to-run-a-method-class-only-on-tomcat-wildfly-glassfish-startup">https://stackoverflow.com/questions/158336/is-there-a-way-to-run-a-method-class-only-on-tomcat-wildfly-glassfish-startup</a></p>
<p>[1] <a href="https://github.com/clojure/tools.nrepl">https://github.com/clojure/tools.nrepl</a><br />[2] <a href="http://central.maven.org/maven2/org/clojure/tools.nrepl/0.2.13/tools.nrepl-0.2.13.jar">http://central.maven.org/maven2/org/clojure/tools.nrepl/0.2.13/tools.nrepl-0.2.13.jar</a><br />[3] <a href="http://doc.ccw-ide.org/">http://doc.ccw-ide.org/</a><br />[4] <a href="https://cider.readthedocs.io/en/latest/">https://cider.readthedocs.io/en/latest/</a><br />[5] <a href="https://leiningen.org/">https://leiningen.org/</a> </p>
<hr />
<h1><a href="#step-six-leiningen" name="step-six-leiningen"></a>Step Six: Leiningen</h1>
<hr />
<p>Up to now we have been downloading JARs from Maven Central and Clojars and put together the classpath by hand. Now we want to use a build tool for that.</p>
<p>Leiningen [1] is an extendable task executor with dependency resolution. We want to use it to setup a project (_scafolding_), to build, run and test the code. Finally we use it to package, release and deploy our application.</p>
<p>First you have to install leiningen.</p>
<p><strong>TODO:</strong> Show install</p>
<p>Now we use <code>lein new</code> to setup a project. We execute this <strong>in</strong> directory <code>solo-project/</code> (use branch <code>step-five</code> to see these changes):</p>
<pre><code>solo-project$ lein new solo --to-dir .
</code></pre>
<p><strong>Note:</strong> This is a little silly – we could have just created and  filled <code>project.clj</code> and <code>solo-project/test/solo/core_test.clj</code>, but  I wanted to show how to set up a project with Leiningen. Usually you  do this when you do not have an existing project structure to start  with.</p>
<p>This will create some new directories &amp; files:</p>
<pre><code>CHANGELOG.md
LICENSE
README.md
doc/intro.md
project.clj
src/solo/core.clj
test/solo/core_test.clj
</code></pre>
<p>We delete <code>rm -rf src/solo/</code> (we already have the Clojure sources below <code>solo-project/src/clj/solo/</code>) and fix <code>project.clj</code>:</p>
<pre><code>(defproject solo "0.1.0-SNAPSHOT"
  :source-paths ["src/clj"]
  :resource-paths ["lib/clojure-1.8.0.jar" "lib/log4j-1.2.17.jar"])
</code></pre>
<p><strong>Note:</strong> I put the <em>Solo</em> Clojure sources below  <code>solo-project/src/clj/solo/</code> and not below <code>solo-project/src/solo/</code>  (where Leiningen puts them), because later on we will also have  ClojureScript sources and they will go to  <code>solo-project/src/cljs/solo/</code>.</p>
<p>And we fix our first tests in <code>solo-project/test/solo/core_test.clj</code>:</p>
<pre><code>(ns solo.core-test
  (:require [clojure.test :refer :all]
            [solo.core :refer :all]))

(deftest a-test
  (testing "Testing solo.core"
    (is (= [] (get-current-loggers)))
    (is (= [{:logger-name "foo"
             :log-level "INFO"}]
           (do ;; mutator!
             (set-log-level! "foo" "INFO")
             (get-current-loggers))))))
</code></pre>
<p>And test:</p>
<pre><code>solo-project$ lein test
lein test solo.core-test

Ran 1 tests containing 2 assertions.
0 failures, 0 errors.
</code></pre>
<p><strong>Dependencies</strong></p>
<p>Instead of supplying the JARs ourselves we can use Leiningen to do that for us. Change <code>solo-project/project.clj</code> to:</p>
<pre><code>(defproject solo "0.1.0-SNAPSHOT"
  :source-paths ["src/clj"]
  :dependencies [[org.clojure/clojure "1.8.0"]
                 [log4j/log4j "1.2.17"]])
</code></pre>
<p>And run the tests again:</p>
<pre><code>lein test
</code></pre>
<p>This will <strong>download</strong> the JARs to <code>~/.m2/repo/</code> (your default local <em>Maven</em> <em>Repository</em> – eventhough we’re not using Maven!) so you’ll need an internet connection for this to work.</p>
<p><strong>Using Leiningen</strong></p>
<p>You can use Leiningen to run the examples from above (steps zero through five) but this time Leiningen will put together the classpath for us.</p>
<ul>
  <li>
    <p><strong>rlwrap &amp; (n)REPL</strong>: the <code>repl</code> task starts an nREPL server and the  local REPL (on your tty). Note that we’re using the Leiningen  built-in nREPL support and not <code>solo.nrepl</code> here (use <code>lein help
  repl</code> for help):</p>
    <pre><code>solo-project$ rlwrap lein repl :start :host 0.0.0.0 :port 7888
nREPL server started on port 7888 on host 0.0.0.0 - nrepl://0.0.0.0:7888
REPL-y 0.3.7, nREPL 0.2.12
Clojure 1.8.0
Java HotSpot(TM) Client VM 1.8.0-ea-b116
    Docs: (doc function-name-here)
          (find-doc "part-of-name-here")
  Source: (source function-name-here)
 Javadoc: (javadoc java-object-or-class-here)
    Exit: Control+D or (exit) or (quit)
 Results: Stored in vars *1, *2, *3, an exception in *e
user=&gt; (use 'solo.core)
nil
user=&gt; (set-log-level! "foo" "INFO")
nil
user=&gt; (get-current-loggers)
({:logger-name "foo", :log-level "INFO"})
</code></pre>
  </li>
  <li>
    <p><strong>rlwrap/nREPL client</strong>: since Leiningen has nREPL server &amp;  <strong>client</strong> built-in, you can use <code>repl :connect</code> to start a REPL  that is connected remotely to the nREPL server port 7888 from above  (so you’re running two Leiningen JVMs for this). Note that you don’t  even need the git workspace (i.e. <code>project.clj</code>) for this – you  just need Leiningen.</p>
    <pre><code>$ rlwrap lein repl :connect 7888
Connecting to nREPL at 127.0.0.1:7888
REPL-y 0.3.7, nREPL 0.2.12
Clojure 1.8.0
Java HotSpot(TM) Client VM 1.8.0-ea-b116
    Docs: (doc function-name-here)
          (find-doc "part-of-name-here")
  Source: (source function-name-here)
 Javadoc: (javadoc java-object-or-class-here)
    Exit: Control+D or (exit) or (quit)
 Results: Stored in vars *1, *2, *3, an exception in *e

user=&gt; (.println System/out "foo")
nil
</code></pre>
  </li>
  <li>
    <p><strong>Swank plugin</strong>: <code>lein-swank</code> [2] is a (deprecated) Leiningen  plugin (for development) that you can put into <code>project.clj</code>:</p>
    <pre><code>(defproject solo "0.1.0-SNAPSHOT"
  :source-paths ["src/clj"]
  :dependencies [[org.clojure/clojure "1.8.0"]
                 [swank-clojure/swank-clojure "1.4.3"]
                 [log4j/log4j "1.2.17"]]
  :plugins [[lein-swank "1.4.5"] ])
</code></pre>
  </li>
</ul>
<p>Now you can run the <code>swank</code> task:</p>
<pre><code>    solo-project$ lein swank 4005 0.0.0.0
    Listening for transport dt_socket at address: 39371
    Connection opened on 0.0.0.0 port 4005.
</code></pre>
<ul>
  <li>
    <p><strong>solo.swank</strong>: Since we want to “use Swank in production” (as part  of our application without Leiningen), we use the <code>run</code> task to  execute <code>-main</code> function in <code>solo-project/src/clj/solo/swank.clj</code>  which start the swank server – like this:</p>
    <pre><code>solo-project$ lein run -m solo.swank
</code></pre>
  </li>
  <li>
    <p><strong>solo.nrepl</strong>: And the same thing for nREPL server:</p>
    <pre><code>solo-project$ lein run -m solo.nrepl/start-server 
Starting nREPL server on port 7888 ...
Started nREPL server on port 7888 : {:class clojure.tools.nrepl.server.Server, :empty false}
</code></pre>
  </li>
</ul>
<p><strong>TODO</strong> fix server-tostring</p>
<p><strong>Leiningen Build</strong></p>
<p><strong>TODO</strong>: build jumpstart-jsf.jar</p>
<p>[1] <a href="https://leiningen.org/">https://leiningen.org/</a><br />[2] <a href="https://github.com/technomancy/swank-clojure">https://github.com/technomancy/swank-clojure</a> </p>
<hr />
<h1><a href="#step-seven-jetty-http-kit-ring-compojure-hiccup-solo-web" name="step-seven-jetty-http-kit-ring-compojure-hiccup-solo-web"></a>Step Seven: jetty, http-kit, ring, compojure, hiccup, solo.web</h1>
<hr />
<p><strong>TODO:</strong> build the typical POST-back/GET web-app. Routing with compojure, HTML markup server-side-generated with hiccup.</p>
<hr />
<h1><a href="#step-eight-clojurescript" name="step-eight-clojurescript"></a>Step Eight: clojurescript</h1>
<hr />
<p><strong>TODO:</strong> introduce clojurescript, compiler, use clojurescript for accessing backend (GET-reads, POST-writes). Hiccup in clojurescript?</p>
<ul>
  <li>
  <p>solo.rest:</p></li>
  <li>
  <p>solo.client.rest</p></li>
</ul>
<hr />
<h1><a href="#step-nine-brepl" name="step-nine-brepl"></a>Step Nine: bREPL</h1>
<hr />
<p><strong>TODO</strong>: the REPL in the browser</p>
<ul>
  <li>testing clojurescript?</li>
</ul>
<hr />
<h1><a href="#step-ten-figwheel" name="step-ten-figwheel"></a>Step Ten: figwheel</h1>
<hr />
<p><strong>TODO</strong>: dynamic code reload while preserving your app-state.</p>
<hr />
<h1><a href="#step-eleven-react-reagent-solo-client-reagent" name="step-eleven-react-reagent-solo-client-reagent"></a>Step Eleven: React, Reagent, solo.client.reagent</h1>
<hr />
<ul>
  <li>dev-cards?</li>
</ul>
<hr />
<h1><a href="#step-12-chord-sente-solo-client-websockets" name="step-12-chord-sente-solo-client-websockets"></a>Step 12: chord, sente, solo.client.websockets</h1>
<hr />
<p><strong>TODO</strong>: full-duplex-async client-server communication</p>
<ul>
  <li>solo.websockets</li>
</ul>
<hr />
<h1><a href="#step-13-package-release-deploy" name="step-13-package-release-deploy"></a>Step 13: Package, Release, Deploy</h1>
<hr />
<p><strong>TODO</strong>: build and use a Web-App (WAR) that you can deploy to JBoss/Wildfly/Websphere to tweak your log4j configuration at runtime.</p>
<hr />
<h1><a href="#notes-todo" name="notes-todo"></a>Notes, TODO</h1>
<hr />
<ul>
  <li>
  <p>Step-four ist noch nicht ok, weil wir dort noch kein nREPL  haben. Wir können also nur Swank starten. In step-five können wir  dann nREPL einführen.</p></li>
  <li>
  <p>setup <code>master</code> branch</p></li>
  <li>
  <p>lein: code, run, test, deploy, release, codox</p></li>
  <li>
  <p>Gorilla REPL: introduce Gorilla REPL</p></li>
</ul></div></div></div></body></html>