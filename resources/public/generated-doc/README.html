<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>From Zero To Hero</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="highlight/solarized-light.css" /><script type="text/javascript" src="highlight/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a> with <a href="https://github.com/xsc/codox-theme-rdash">RDash UI</a> theme</h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Solo</span> <span class="project-version">0.1.0-SNAPSHOT</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1 "><a href="intro.html"><div class="inner"><span>Einführung in Solo</span></div></a></li><li class="depth-1  current"><a href="README.html"><div class="inner"><span>From Zero To Hero</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>solo</span></div></div></li><li class="depth-2 branch"><a href="solo.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-2 branch"><a href="solo.jetty.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>jetty</span></div></a></li><li class="depth-2"><a href="solo.jumpstart.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>jumpstart</span></div></a></li><li class="depth-3"><a href="solo.jumpstart.servlet_container_initializer.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>servlet_container_initializer</span></div></a></li><li class="depth-2 branch"><a href="solo.main.html"><div class="inner"><span class="tree" style="top: -52px;"><span class="top" style="height: 61px;"></span><span class="bottom"></span></span><span>main</span></div></a></li><li class="depth-2 branch"><a href="solo.nrepl.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>nrepl</span></div></a></li><li class="depth-2 branch"><a href="solo.swank.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>swank</span></div></a></li><li class="depth-2"><a href="solo.web.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>web</span></div></a></li><li class="depth-3"><a href="solo.web.spa.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>spa</span></div></a></li><li class="depth-2"><a href="solo.webapp.html"><div class="inner"><span class="tree" style="top: -52px;"><span class="top" style="height: 61px;"></span><span class="bottom"></span></span><span>webapp</span></div></a></li></ul></div><div class="document" id="content"><div class="doc"><div class="markdown"><hr />
<h1><a href="#from-zero-to-hero" name="from-zero-to-hero"></a>From Zero To Hero</h1>
<hr />
<p>This is a Clojure <a href="https://clojure.org/">https://clojure.org/</a> / ClojureScript <a href="https://clojurescript.org/">https://clojurescript.org/</a> tutorial.</p>
<p>We will build an application (_Solo_ [1]) that lets you control log4j [2] log-levels at runtime. <em>Solo</em> has a browser-based frontend (ClojureScript/JavaScript) and a backend running in the JVM (Clojure).</p>
<p>Something similar has been done before (in Java): <code>https://github.com/mrsarm/log4jwebtracker</code></p>
<p>You can <em>mix</em> <em>Solo’s</em> backend with other JVM-applications (I’m targeting Java applications running in Wildfly/JBoss and Websphere) so that you can change logging configuration at runtime which is a nice feature for test, QA and production (many logging libraries and JEE servers support JMX [3] for this use-case [4], IBM Websphere has dynamic control over logging built in).</p>
<p>This tutorial is ment as a starter for people with little Clojure background. It will not explain/teach Clojure (you can find many good tutorials on THE NET) but show which libraries and tools are used to build and run the application and how to put it into production.</p>
<p>[1] <a href="https://github.com/henrik42/solo">https://github.com/henrik42/solo</a><br />[2] <a href="https://logging.apache.org/log4j/1.2/">https://logging.apache.org/log4j/1.2/</a><br />[3] <a href="http://www.oracle.com/technetwork/articles/java/javamanagement-140525.html">http://www.oracle.com/technetwork/articles/java/javamanagement-140525.html</a><br />[4] <a href="https://logging.apache.org/log4j/2.0/manual/jmx.html">https://logging.apache.org/log4j/2.0/manual/jmx.html</a> </p>
<hr />
<h1><a href="#step-zero-just-clojure" name="step-zero-just-clojure"></a>Step Zero: Just Clojure</h1>
<hr />
<p>You can try all of the following examples from the git <code>master</code> branch. If you want to see how the workspace evolves from one step to the next you can <code>git clone</code> the repo and checkout the branches for each step – like so (assuming you checked out the repo to <code>solo-project/</code>):</p>
<pre><code>solo-project$ git checkout step-zero
Switched to branch 'step-zero'
</code></pre>
<p>For our first Clojure program we just need Java 1.8 JDK [1] and a Clojure 1.8.x JAR. Download Clojure 1.8.0 [2] into <code>solo-project/lib/clojure-1.8.0.jar</code> and execute:</p>
<pre><code>solo-project$ java -cp lib/\* clojure.main -e '(println "Hello, Clojure")'
Hello, Clojure
</code></pre>
<p>Here we’re executing the Clojure code from command line arguments.</p>
<p>[1] <a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html">http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a><br />[2] <a href="https://repo1.maven.org/maven2/org/clojure/clojure/1.8.0/clojure-1.8.0.jar">https://repo1.maven.org/maven2/org/clojure/clojure/1.8.0/clojure-1.8.0.jar</a> </p>
<hr />
<h1><a href="#step-one-log4j-solo-core" name="step-one-log4j-solo-core"></a>Step One: log4j, solo.core</h1>
<hr />
<p>Now we’re ready to implement the <em>core logic</em> of <em>Solo</em>.</p>
<p>First download <code>log4j-1.2.17.jar</code> [1] to <code>solo-project/lib/log4j-1.2.17.jar</code>.</p>
<p>Next create <code>solo-project/src/clj/solo</code>:</p>
<pre><code>solo-project$ mkdir -p src/clj/solo
</code></pre>
<p>All this has already been done for you in branch <code>step-one</code>.</p>
<p>There are just a few functions in <code>solo-project/src/clj/solo/core.clj</code> for retrieving the current log4j loggers and for setting the log-level of a logger. That’s all we need.</p>
<p>This is the relevant part of the code:</p>
<pre><code>(ns solo.core
  (:import [org.apache.log4j Logger Level]))

(defn logger-&gt;map [log4j-logger]
  {:logger-name (.getName log4j-logger)
   :log-level (-&gt; log4j-logger .getLevel str)})

(defn get-logger [logger-name]
  (-&gt; (if (= "root" logger-name)
        (Logger/getRootLogger)
        (Logger/getLogger logger-name))
      logger-&gt;map))

(defn set-log-level! [logger-name log-level]
  (-&gt; (if (= "root" logger-name)
        (Logger/getRootLogger)
        (Logger/getLogger logger-name))
      (.setLevel (Level/toLevel log-level))))

(defn get-current-loggers []
  (map logger-&gt;map
       (conj
        (-&gt; (Logger/getRootLogger)
            .getLoggerRepository
            .getCurrentLoggers
            enumeration-seq)
        (Logger/getRootLogger))))
</code></pre>
<p>And run it:</p>
<pre><code>solo-project$ java -cp lib/\*:src/clj clojure.main \
  -e "(use 'solo.core) (set-log-level! \"foo\" \"INFO\") (get-current-loggers)"
</code></pre>
<p>Output:</p>
<pre><code>({:logger-name "root", :log-level "DEBUG"} {:logger-name "foo", :log-level "INFO"})
</code></pre>
<p>Instead of running the code from command-line arguments you can execute any script file and put the code in there. For example, let’s put the following code into <code>solo-project/scripts/script-one.clj</code>:</p>
<pre><code>(use 'solo.core)
(set-log-level! "foo" "INFO")
(println (get-current-loggers))
</code></pre>
<p>And run:</p>
<pre><code>solo-project$ java -cp lib/\*:src/clj clojure.main scripts/script-one.clj
</code></pre>
<p>Output:</p>
<pre><code>({:logger-name root, :log-level DEBUG} {:logger-name foo, :log-level INFO})
</code></pre>
<p>Note that executing a script only evaluates the script <em>forms</em> but does <strong>not</strong> <strong>print</strong> their (the forms’) values.</p>
<p>Try changing the last line to</p>
<pre><code>(get-current-loggers)
</code></pre>
<p>Now re-run the command from above. It won’t print anything. Now run this instead:</p>
<pre><code>solo-project$ java -cp lib/\*:src/clj clojure.main -e '(load-file "scripts/script-one.clj")'
</code></pre>
<p>Output:</p>
<pre><code>({:logger-name "root", :log-level "DEBUG"} {:logger-name "foo", :log-level "INFO"})
</code></pre>
<p>So <code>-e</code> prints the result of the <strong>last</strong> <strong>evaluated</strong> <em>form</em>.</p>
<p><strong>Note:</strong> Clojure <em>script files</em> and “regular” Clojure code look almost the same and they can basically contain the same forms. But you <strong>load</strong> them differently. Script files are loaded directly by reading in the source forms (via file-io or from a socket or from an in-memory <code>String</code>). <em>Namespaced</em> code is loaded via a classpath lookup for AOT-compiled code and sources (see “Step Four” below). Do not confuse the two.</p>
<p>Finally we want to use a log4j configuration file for setting up our root logger and appenders. You can use this for testing. In <em>production</em> (see below) we’ll have a <em>host-application</em> which will do the log4j set-up.</p>
<p>Try:</p>
<pre><code>solo-project$ java -cp lib/\*:src/clj clojure.main \
  -e "(use 'solo.core)" \
  -e "(-&gt; (org.apache.log4j.Logger/getLogger \"foo\") (.info \"bar\"))"
</code></pre>
<p>Output:</p>
<pre><code>log4j:WARN No appenders could be found for logger (foo).
log4j:WARN Please initialize the log4j system properly.
log4j:WARN See http://logging.apache.org/log4j/1.2/faq.html#noconfig for more info.
</code></pre>
<p>We haven’t initialited log4j! So let’s do that:</p>
<pre><code>solo-project$ java -Dlog4j.debug=true -Dlog4j.configuration=file:log4j.properties \
  -cp lib/\*:src/clj clojure.main \
  -e "(-&gt; (org.apache.log4j.Logger/getLogger \"foo\") (.info \"bar\"))" \
  -e "(use 'solo.core) (get-current-loggers)"
</code></pre>
<p>Which gives you:</p>
<pre><code>log4j: Using URL [file:log4j.properties] for automatic log4j configuration.
log4j: Reading configuration from URL file:log4j.properties
log4j: Parsing for [root] with value=[INFO,con].
log4j: Level token is [INFO].
log4j: Category root set to INFO
log4j: Parsing appender named "con".
log4j: Parsing layout options for "con".
log4j: Setting property [conversionPattern] to [%d{yyyy-MM-dd HH:mm:ss} %-5p %c{1}:%L - %m%n].
log4j: End of parsing for "con".
log4j: Setting property [target] to [System.out].
log4j: Parsed "con" options.
log4j: Finished configuring.
2018-05-23 06:28:58 INFO  foo:1 - bar
({:logger-name "root", :log-level "INFO"} {:logger-name "foo", :log-level ""})
</code></pre>
<p><strong>Note:</strong> <code>log4j.debug=true</code> has nothing to do with <code>DEBUG</code> log-levels! It just means, that log4j prints some <code>log4j:</code> log-messages to STDOUT when settings up log4j etc.</p>
<p>[1] I’m using the old log4j 1.2 but you should be able to switch to 2.x <a href="http://central.maven.org/maven2/log4j/log4j/1.2.17/log4j-1.2.17.jar">http://central.maven.org/maven2/log4j/log4j/1.2.17/log4j-1.2.17.jar</a> </p>
<hr />
<h1><a href="#step-two-rlwrap-repl" name="step-two-rlwrap-repl"></a>Step Two: rlwrap, REPL</h1>
<hr />
<p>Clojure is a <strong>compiled</strong> language and still you can use the runtime environment interactively using the <em>REPL</em> <a href="read-eval-print-loop">1</a>. The Clojure <em>forms</em> are compiled <em>just-in-time</em> while they are read from file/keyboard/etc (and there is also ahead-of-time/AOT [2] compilation).</p>
<p>When running on Linux it’s nice to use <code>rlwrap</code> [3]. This way you get <code>readline</code>-like (as in a <code>bash</code>) line-editing features (incl. command history).</p>
<pre><code>solo-project$ rlwrap java -cp lib/\*:src/clj clojure.main 
Clojure 1.8.0
user=&gt; (use 'solo.core)
nil
user=&gt; (set-log-level! "foo" "INFO")
nil
user=&gt; (get-current-loggers)
({:logger-name "foo", :log-level "INFO"})
user=&gt; ^D
</code></pre>
<p>If you change <code>solo/core.clj</code> after loading the namespace <code>solo.core</code> you can use <code>:reload</code> to see the changes in your REPL. So you <strong>need</strong> <strong>not</strong> restart your JVM and you do not lose your internal program state (e.g. any loggers you my have created):</p>
<pre><code>(use 'solo.core :reload)
</code></pre>
<p>More on REPL at <a href="https://clojure.org/guides/repl/introduction">https://clojure.org/guides/repl/introduction</a></p>
<p>[1] <a href="https://clojure.org/reference/repl_and_main">https://clojure.org/reference/repl_and_main</a><br />[2] <a href="https://clojure.org/reference/compilation">https://clojure.org/reference/compilation</a><br />[3] <a href="https://github.com/hanslub42/rlwrap">https://github.com/hanslub42/rlwrap</a> </p>
<hr />
<h1><a href="#step-three-swank-emacs-slime" name="step-three-swank-emacs-slime"></a>Step Three: Swank, Emacs/SLIME</h1>
<hr />
<p>We want to use an editor to edit the code and to evaluate our changes without starting the JVM over and over again each time we change our code. You can do this by reloading the code as shown in step two.</p>
<p>Another way to do this is to connect Emacs/SLIME [1] to the running JVM via <em>Swank</em> [2] (eventhough it’s deprecated). Download <code>swank-clojure-1.4.3.jar</code> [3] and <code>clj-stacktrace-0.2.4.jar</code> [4] to <code>solo-project/lib/</code>.</p>
<p>First we start the <em>Swank</em> server.</p>
<pre><code>solo-project$ java -cp lib/\*:src/clj clojure.main -m swank.swank 4005
</code></pre>
<p>Now connect from Emacs.</p>
<p>If you like to use Emacs/SLIME <strong>and</strong> have a REPL prompt at the same time, try this:</p>
<pre><code>solo-project$ rlwrap java -cp lib/\*:src/clj clojure.main \
  -e "(use 'swank.swank) (start-server :host \"0.0.0.0\" :port 4005)" \
  -r
Connection opened on 0.0.0.0 port 4005.
user=&gt; 
</code></pre>
<p>I’m using host/IP <code>0.0.0.0</code> so that you can run this on some Linux server in your office network and connect to the Swank server from your desktop PC running Emacs/SLIME (if you were using <code>127.0.0.1</code> you couldn’t connect from any remote host).</p>
<p><strong>WARNING:</strong> Note that <strong>anyone</strong> can connect to the JVM from any host  that can reach your host (via a TCP/IP route) and thus has full  control over the running JVM. So do this only on <strong>trusted</strong>  <strong>networks</strong>!</p>
<p>If you’re running Emacs and Clojure/JVM on the <strong>same</strong> <strong>machine</strong>  you should use <code>127.0.0.1</code> (do <strong>not</strong> use <code>localhost</code> since you  cannot be sure which IP it is mapped to on hosts that you do not  control!) instead of <code>0.0.0.0</code>. Use <code>127.0.0.1</code> together with an SSL  tunnel to remotely connect from a <strong>trusted</strong> <strong>host</strong> running  Emacs/SLIME to the <strong>trusted</strong> <strong>host</strong> running Clojure over an  <strong>untrusted</strong> network.</p>
<p>Finally we can put the code into <code>src/clj/solo/swank.clj</code> for re-use:</p>
<pre><code>(ns solo.swank
  (require [swank.swank :as swank]))

(defn start-server [&amp; {:keys [port host]
                       :or {port 4005 host "0.0.0.0"}}]
  (let [params {:port port :host host}
        _ (.println System/out (str "Starting Swank server on " params " ..."))
        server (try
                 (swank/start-server :port port :host host)
                 (catch Throwable t
                   (throw (ex-info
                           (format "Could not start Swank server: %s Cause: %s" params t)
                           params t))))]
    (.println System/out (str "Started Swank server on " params "."))
    server))

(defn stop-server []
  (swank/stop-server))

(defn -main [&amp; args]
  (let [{:keys [host port] :or {host "0.0.0.0" port 4005}}
        (map (comp read-string str) args)]
    (start-server :port port :host host)))
</code></pre>
<p>The <code>-main</code> function is (by convention) special – it can be run like shown next (note that it will receive <code>String</code>-type arguments when called from command-line)</p>
<pre><code>solo-project$ rlwrap java -cp lib/\*:src/clj clojure.main -m solo.swank :port 4006
Connection opened on 0.0.0.0 port 4006.
</code></pre>
<p>If you want the REPL also you can do this (here we’re loading <code>swank.clj</code> as a script):</p>
<pre><code>solo-project$ rlwrap java -cp lib/\*:src/clj clojure.main \
              -i src/clj/solo/swank.clj \
              -e "(solo.swank/start-server :port 4006)" \
              -r
Starting Swank server on {:port 4006, :host "0.0.0.0"} ...
Connection opened on 0.0.0.0 port 4006.
Started Swank server on {:port 4006, :host "0.0.0.0"}.
user=&gt; 
</code></pre>
<p>Now you can use the <strong>REPL</strong> <strong>and/or</strong> <strong>Emacs</strong> to evaluate code and to reload changes you make to <code>core.clj</code> and switch back and forth between them.</p>
<p>[1] <a href="https://common-lisp.net/project/slime/">https://common-lisp.net/project/slime/</a><br />[2] <a href="https://github.com/technomancy/swank-clojure">https://github.com/technomancy/swank-clojure</a><br />[3] <a href="https://repo.clojars.org/swank-clojure/swank-clojure/1.4.3/swank-clojure-1.4.3.jar">https://repo.clojars.org/swank-clojure/swank-clojure/1.4.3/swank-clojure-1.4.3.jar</a><br />[4] <a href="https://repo.clojars.org/clj-stacktrace/clj-stacktrace/0.2.4/clj-stacktrace-0.2.4.jar">https://repo.clojars.org/clj-stacktrace/clj-stacktrace/0.2.4/clj-stacktrace-0.2.4.jar</a> </p>
<hr />
<h1><a href="#step-four-containers-solo-jumpstart" name="step-four-containers-solo-jumpstart"></a>Step Four: Containers, solo.jumpstart</h1>
<hr />
<p>We want to use <em>Solo</em> within an <em>host-application</em> – i.e. a Java application that does not offer changing log4j log-levels at runtime out-of-the-box. We want to hook <em>Solo</em> into this host-application changing as little as possible about the host-application’s configuration.</p>
<p>Since the host-application does not know about <em>Solo</em> (so it will not give us any way of using it), we will start a “server” (we could use Swank, but there are more options; see below) that will listen for connections and through this server we can control <em>Solo</em> remotely from the outside.</p>
<p>When you’re working in a Java-shop you may be using JEE application servers (like JBoss, Wildfly, IBM Websphere) or other containers (like Tomcat, Jetty, Spring Boot). Usually the applications that run in these containers will be Java applications with no Clojure included. These applications do not know about Clojure or <em>Solo</em> and they probably have no built-in way of executing arbitrary code/classes. So in order to run/use <em>Solo</em>, we somehow have to gain control over an execution thread … the host-application has to <em>jump-start</em> <em>Solo</em> (implicitly).</p>
<p>There are many things going on in typical Java applications that let you gain control – i.e. to have you jump-started:</p>
<ul>
  <li><strong>Context Dependency Injection</strong>: CDI [1a, 1b] (and SPI [2a, 2b]  architectures in general) lets you <em>extend</em> the functionality of a  CDI implementation.</li>
  <li><strong>Java Server Faces</strong>: JSF [3] has ways to supply and discover  <em>managed beans</em>. So you can use this mechanism to make the JSF  runtime call your code.</li>
  <li><strong>Spring IoC</strong>: Spring [4] lets you define Spring beans that can run  your code.</li>
  <li><strong>log4j</strong>: log4j [5] lets you name and load <code>Logger</code> implementations  and you can supply yours. When the logger’s class gets loaded you  can run your code.</li>
  <li><strong>JDK Resource Bundle</strong>: <code>ResourceBundle</code> [6] has a class-loading  mechanism, so if you can make the host-application load a specific  <code>ResourceBundle</code>, it will execute your code.</li>
</ul>
<p>There are more things you can do:</p>
<ul>
  <li><strong>deploy an EJB</strong>: package an EJB with our code and deploy that (and  the libs) into your JEE server. Your EJB will be instantiated so you  can do what you need to. You can even use JEE-annotations for  Clojure-generated classes.</li>
  <li><strong>deploy a WAR</strong>: package a WAR (incl. the libs), which you can then  deploy to JEE containers as well as servlet containers. This way you  can deliver a servlet which again will be initialized and run.</li>
  <li><strong>deploy a JAR</strong>: package a JAR, which contains some/any of the  artifacts mentioned above.</li>
</ul>
<p>All of these <strong>frameworks</strong> have one in common: you have to deliver a <strong>named class</strong> for them to call your code. You cannot just deliver Clojure source code and let the framework reflectively call <code>clojure.lang.RT.load(&lt;your-namespace&gt;)</code>. Some of them let you supply annotated classes which are then picked up by the framework via classpath scanning.</p>
<p><strong>Note</strong>: Spring has a mechanism that lets you use <code>clojure.RT</code> to execute Clojure <strong>source</strong> [7].</p>
<p>So we have to use <code>gen-class</code> to deliver that class. This class is just used for <strong>loading</strong> your namespace and <strong>calling</strong> a <code>jumpstart</code> function!</p>
<p>But it does not suffice to just deliver the classes for your jumpstart-namespace. You also have to deliver the JARs under <code>solo-project/lib/</code> so you can use them (except – probably – log4j JAR). At this point you have to understand how classloaders work and how the mentioned frameworks organize the classloaders they use.</p>
<p>In many cases your class will be loaded by a classloader that has no access (neither direct nor by delegation to other <em>co-laborating</em> classloaders) to the host-application’s classes (incl. log4j). Sometimes the jumpstart-class does not even <em>see</em> the Clojure runtime-classes eventhough you supplied the libs. This usually leads to <code>ClassNotFoundException</code> and then <code>NoClassDefFoundException</code> when loading your jumpstart-namespace.</p>
<p>You find examples/solutions for some cases below.</p>
<p>[1a] <a href="https://docs.jboss.org/cdi/spec/1.0/html/">https://docs.jboss.org/cdi/spec/1.0/html/</a> [1b] <a href="https://jaxenter.com/tutorial-introduction-to-cdi-contexts-and-dependency-injection-for-java-ee-jsr-299-104536.html">https://jaxenter.com/tutorial-introduction-to-cdi-contexts-and-dependency-injection-for-java-ee-jsr-299-104536.html</a><br />[2a] <a href="https://docs.oracle.com/javase/tutorial/sound/SPI-intro.html">https://docs.oracle.com/javase/tutorial/sound/SPI-intro.html</a><br />[2b] <a href="https://docs.oracle.com/javase/tutorial/ext/basics/spi.html">https://docs.oracle.com/javase/tutorial/ext/basics/spi.html</a><br />[3] <a href="http://www.oracle.com/technetwork/java/javaee/javaserverfaces-139869.html">http://www.oracle.com/technetwork/java/javaee/javaserverfaces-139869.html</a><br />[4] <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html">https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html</a><br />[5] <a href="https://logging.apache.org/log4j/1.2/">https://logging.apache.org/log4j/1.2/</a><br />[6] <a href="https://docs.oracle.com/javase/8/docs/api/java/util/ResourceBundle.html">https://docs.oracle.com/javase/8/docs/api/java/util/ResourceBundle.html</a><br />[7] <a href="https://github.com/henrik42/spring-break">https://github.com/henrik42/spring-break</a> </p>
<h2><a href="#solo-jumpstart-servlet-container-initializer" name="solo-jumpstart-servlet-container-initializer"></a>solo.jumpstart.servlet_container_initializer</h2>
<p>Here we jump-start <em>Solo</em> via <code>ServletContainerInitializer</code> [1]. This means we use a web-application’s start-up mechanism to have <em>Solo</em> jump-started.</p>
<p>We supply the resource <code>META-INF/services/javax.servlet.ServletContainerInitializer</code> with content:</p>
<pre><code>solo.jumpstart.servlet_container_initializer
</code></pre>
<p>This makes the servlet-container load this <strong>named</strong> <strong>class</strong> (see above), create an instance and call <code>onStartup</code> method on this instance.</p>
<p><strong>The simplest thing that can possibly work</strong></p>
<p>In <code>jumpstart/src/solo/jumpstart/servlet_container_initializer.clj</code> you find the source that we AOT-compile/<code>:gen-class</code> to get the class <code>solo.jumpstart.servlet_container_initializer</code>.</p>
<p>This first version (not committed to git! So you have to change the source code to try this) does not seem to do <em>anything</em> ;-)</p>
<pre><code>(ns solo.jumpstart.servlet_container_initializer
  (:gen-class
   :implements [javax.servlet.ServletContainerInitializer]))

(defn -main [&amp; _])
</code></pre>
<p>For compile &amp; packaging you can use <code>scripts/make-jumpstart-jar.sh</code> (<code>compile</code> is just a function you can call – any time, any where)</p>
<pre><code>#!/bin/bash -ex

mkdir -p classes/
rm -rf classes/*
java -cp jumpstart/src/:classes/:lib/clojure-1.8.0.jar:lib/javax.servlet-api-3.1.0.jar clojure.main \
-e "(compile 'solo.jumpstart.servlet_container_initializer)"
jar -vcf jumpstart.jar -C classes/ solo
jar -vuf jumpstart.jar -C jumpstart/resources/ META-INF
</code></pre>
<p>The JAR <code>jumpstart.jar</code> should look like this – including <code>solo/jumpstart/servlet_container_initializer.class</code>!</p>
<pre><code>solo-project$ jar -vtf jumpstart.jar 
    68 Fri Jun 01 17:40:32 UTC 2018 META-INF/MANIFEST.MF
     0 Fri Jun 01 17:40:32 UTC 2018 solo/
     0 Fri Jun 01 17:40:32 UTC 2018 solo/jumpstart/
   844 Fri Jun 01 17:40:32 UTC 2018 solo/jumpstart/servlet_container_initializer$_main.class
  1646 Fri Jun 01 17:40:32 UTC 2018 solo/jumpstart/servlet_container_initializer$loading__5569__auto____3.class
  2376 Fri Jun 01 17:40:32 UTC 2018 solo/jumpstart/servlet_container_initializer.class
  1494 Fri Jun 01 17:40:32 UTC 2018 solo/jumpstart/servlet_container_initializer$fn__5.class
  2722 Fri Jun 01 17:40:32 UTC 2018 solo/jumpstart/servlet_container_initializer__init.class
     0 Mon May 28 06:12:32 UTC 2018 META-INF/services/
    44 Mon May 28 06:12:32 UTC 2018 META-INF/services/javax.servlet.ServletContainerInitializer
</code></pre>
<p>For this very first test you can run this class via <code>solo.jumpstart.servlet_container_initializer/-main</code>. We’ll use Clojure’s built-in <em>Socket Server</em> to talk to <em>Solo</em> remotely. All we have to do is to define the system property <code>clojure.server.repl</code>. This will make Clojure start a server (when Clojure <em>bootstraps</em>) on port 5555 to which you can then connect via <em>Netcat</em> [2].</p>
<pre><code>solo-project$ java \
              -Dclojure.server.repl="{:server-daemon false :port 5555 :accept clojure.core.server/repl}" \
              -cp src/clj/:jumpstart.jar:lib/\* \
              solo.jumpstart.servlet_container_initializer
</code></pre>
<p>And in a second shell:</p>
<pre><code>$ nc 127.0.0.1 5555 &lt;&lt; EOF
(use 'solo.core)
(get-current-loggers)
EOF
</code></pre>
<p>Running this will give you:</p>
<pre><code>$ nc 127.0.0.1 5555 &lt;&lt; EOF
&gt; (use 'solo.core)
&gt; (get-current-loggers)
&gt; EOF
user=&gt; nil
user=&gt; ({:logger-name "root", :log-level "DEBUG"})
</code></pre>
<p><strong>Recap</strong></p>
<p>We have (1) <em>Solo’s</em> core logic and (2) a (basically empty) named class that bootstraps Clojure and the socket server. This is enough to go into production. You clould <em>deploy</em> this to a JEE application server and then use <em>Netcat</em> remotely to control your log4j log-levels (… and a lot more …).</p>
<p>[1] <a href="https://docs.oracle.com/javaee/7/api/javax/servlet/ServletContainerInitializer.html">https://docs.oracle.com/javaee/7/api/javax/servlet/ServletContainerInitializer.html</a><br />[2] <a href="https://en.wikipedia.org/wiki/Netcat">https://en.wikipedia.org/wiki/Netcat</a></p>
<h2><a href="#jetty-runner" name="jetty-runner"></a>Jetty-Runner</h2>
<p>So this is it! All we need to do is to (1) deploy <code>jumpstart.jar</code> and <code>clojure-1.8.0.jar</code> to a web-container (2) tweak the web-application’s classpath so that it contains <code>src/clj</code> (so it sees <code>solo.core</code> namespace) and to define the system property <code>clojure.server.repl</code>.</p>
<p>Of course we could build &amp; package <code>solo.core</code> into a JAR also and then deploy that instead of putting the source onto the classpath.</p>
<p>We can then connect to <em>Solo</em> with <em>Netcat</em> and control log4j log-levels.</p>
<p>Some things to note:</p>
<ul>
  <li>
  <p>We don’t need <code>-main</code> for jump-starting <em>Solo</em> via  <code>ServletContainerInitializer</code> in production. It’s just there so that  <code>gen-class</code> generates the main-entry method <code>public static void
  main(String[])</code> for us so that we can run it from command-line for  testing.</p></li>
  <li>
  <p>The generated class file  <code>solo/jumpstart/servlet_container_initializer.class</code> bootstraps the  Clojure runtime and then loads the namespace  <code>solo.jumpstart.servlet_container_initializer</code>.</p></li>
  <li>
  <p>The classpath above did not include  <code>solo-project/jumpstart/src/</code>. So the compiled namespace  <code>solo.jumpstart.servlet_container_initializer</code> is <strong>included</strong> in  the JAR. Still the Clojure <em>loader</em> will search for the <strong>source</strong>  <code>solo/jumpstart/servlet_container_initializer.clj</code> when loading the  namespace and only if it cannot find the source it will use the  compiled version. So you can <em>over-write</em> the compiled version in  your production runtime if you need.</p></li>
</ul>
<p>Now let’s use Jetty-Runner [1] for a first test involving a web-container. For this we need an host-application – a web-app. I simply use <code>jetty-and-log4j-example</code> [2]. Checkout and then build with Maven:</p>
<pre><code>jetty-log4j-test-webapp$ mvn clean install
</code></pre>
<p>Now run (I’ve put <code>--lib lib/</code> in there so that Swank JAR is on the classpath too):</p>
<pre><code>solo-project$ java \
              -Dclojure.server.repl="{:server-daemon false :port 5555 :accept clojure.core.server/repl}" \
              -jar lib/jetty-runner-9.4.9.v20180320.jar \
              --jar jumpstart.jar \
              --lib lib/ \
              --classes src/clj \
              jetty-log4j-test-webapp-1.0-SNAPSHOT.war
</code></pre>
<p>Let’s try what we’ve built so far:</p>
<pre><code>from-zero-to-hero$ rlwrap nc 127.0.0.1 5555 &lt;&lt; EOF
(use 'solo.core)
(use 'solo.swank)
(start-server)
(get-current-loggers)
EOF
</code></pre>
<p>You could deploy these JARs to other containers (JBoss/Wildfly, Websphere). We’ll see these use cases later on when we’ve re-worked the jump-start a little.</p>
<p>[1] <a href="https://mvnrepository.com/artifact/org.eclipse.jetty/jetty-runner/9.4.10.v20180503">https://mvnrepository.com/artifact/org.eclipse.jetty/jetty-runner/9.4.10.v20180503</a><br />[2] <a href="https://github.com/jetty-project/jetty-and-log4j-example/tree/master/jetty-log4j-test-webapp">https://github.com/jetty-project/jetty-and-log4j-example/tree/master/jetty-log4j-test-webapp</a> </p>
<h2><a href="#solo-jumpstart-jumpstart" name="solo-jumpstart-jumpstart"></a>solo.jumpstart/jumpstart</h2>
<p>In the end we want to use <code>jumpstart.jar</code> just for loading Clojure and delegation logic. The <em>real</em> logic that we want to have jump-started will come from <code>(solo.jumpstart/jumpstart)</code>. This way we can implement more jump-start mechanisms and still only have one place where we code what should happen when the jump-start occurs. And starting the socket server is only one of many things that we can do.</p>
<p>So <code>src/solo/jumpstart/servlet_container_initializer.clj</code> becomes a <em>loader</em> for <code>solo.jumpstart/jumpstart</code>:</p>
<pre><code>(ns solo.jumpstart.servlet_container_initializer
  (:gen-class
   :implements [javax.servlet.ServletContainerInitializer]))

(defn -onStartup [&amp; args]
  (println "solo.jumpstart.servlet_container_initializer/-onStartup")
  ;; solo.jumpstart is a RUNTIME dependency -- not a COMPILE-TIME! So
  ;; we won't let the compiler/build know what we are doing.
  (try 
    (require 'solo.jumpstart)
    (eval (read-string "(solo.jumpstart/jumpstart)"))
    (catch Throwable t
      (println
       (str "solo.jumpstart.servlet_container_initializer/-onStartup:"
            "Load/run (solo.jumpstart/jumpstart) failed : "
            t)))))

(defn -main [&amp; args]
  (-onStartup))
</code></pre>
<p>Now let’s put your jump-start logic into <code>src/clj/solo/jumpstart.clj</code>. Here we just start Swank:</p>
<pre><code>(ns solo.jumpstart
  (:require [solo.swank :as swank]))

(defn jumpstart []
  (println "solo.jumpstart/jumpstart: starting up:")
  (swank/start-server)
  (println "solo.jumpstart/jumpstart: done."))
</code></pre>
<p>First build <code>jumpstart.jar</code>: <code>solo-project$ ./scripts/make-jumpstart-jar.</code></p>
<p>Again we can test with or with no container:</p>
<pre><code>solo-project$ java \
              -Dclojure.server.repl="{:server-daemon false :port 5555 :accept clojure.core.server/repl}" \
              -jar lib/jetty-runner-9.4.9.v20180320.jar \
              --jar jumpstart.jar \
              --lib lib/ \
              --classes src/clj \
              jetty-log4j-test-webapp-1.0-SNAPSHOT.war
</code></pre>
<p>You can now connect</p>
<ul>
  <li>via Swank/SLIME</li>
  <li>via <em>Netcat</em></li>
  <li>and/or via a browser to <code>http://localhost:8080</code></li>
</ul>
<p>When you do this, try submitting the HTML form. You should see a log4j warning:</p>
<pre><code>log4j:WARN No appenders could be found for logger (org.eclipse.jetty.examples.logging.EchoFormServlet).
log4j:WARN Please initialize the log4j system properly.
log4j:WARN See http://logging.apache.org/log4j/1.2/faq.html#noconfig for more info.
</code></pre>
<p>Oops – we haven’t initialized log4j! Let’s see ….</p>
<pre><code>solo-project$ echo "(use 'solo.core) (get-current-loggers)" | nc 127.0.0.1 5555
({:logger-name "root", :log-level "DEBUG"} {:logger-name "org.eclipse.jetty.examples.logging.EchoFormServlet", :log-level ""})
</code></pre>
<p>OK. The logger is there but no one can log anything. Now let’s try to initialize log4j properly:</p>
<pre><code>solo-project$ java \
              -Dlog4j.debug=true -Dlog4j.configuration=file:log4j.properties \
              -Dclojure.server.repl="{:server-daemon false :port 5555 :accept clojure.core.server/repl}" \
              -jar lib/jetty-runner-9.4.9.v20180320.jar \
              --jar jumpstart.jar \
              --lib lib/ \
              --classes src/clj \
              jetty-log4j-test-webapp-1.0-SNAPSHOT.war
</code></pre>
<p>This time when you submit the HTML form you should see something like:</p>
<pre><code>log4j: Using URL [file:log4j.properties] for automatic log4j configuration.
log4j: Reading configuration from URL file:log4j.properties
log4j: Parsing for [root] with value=[INFO,con].
log4j: Level token is [INFO].
log4j: Category root set to INFO
log4j: Parsing appender named "con".
log4j: Parsing layout options for "con".
log4j: Setting property [conversionPattern] to [%d{yyyy-MM-dd HH:mm:ss} %-5p %c{1}:%L - %m%n].
log4j: End of parsing for "con".
log4j: Setting property [target] to [System.out].
log4j: Parsed "con" options.
log4j: Finished configuring.
2018-06-02 07:23:52 INFO  EchoFormServlet:28 - Got request from 127.0.0.1 using Lynx/2.8.8dev.9 libwww-FM/2.14 SSL-MM/1.4.1 GNUTLS/2.12.14
2018-06-02 07:23:52 INFO  EchoFormServlet:62 - [form] description = ""
2018-06-02 07:23:52 INFO  EchoFormServlet:62 - [form] title = ""
</code></pre>
<p>Now let’s try to set the log-level:</p>
<pre><code>solo-project$ echo '(set-log-level! "org.eclipse.jetty.examples.logging.EchoFormServlet" "OFF")' |\
              nc 127.0.0.1 5555
</code></pre>
<p>When you submit the HTML form again you should see no log-message for <code>EchoFormServlet</code>.</p>
<h2><a href="#deployment-into-production" name="deployment-into-production"></a>Deployment into Production</h2>
<p><strong>TBD</strong></p>
<h3><a href="#wildfly-jboss" name="wildfly-jboss"></a>Wildfly/JBoss</h3>
<p><strong>TBD</strong></p>
<h3><a href="#websphere" name="websphere"></a>Websphere</h3>
<p><strong>TBD</strong></p>
<h3><a href="#tomcat" name="tomcat"></a>Tomcat</h3>
<p><strong>TBD</strong></p>
<hr />
<h1><a href="#step-five-nrepl" name="step-five-nrepl"></a>Step Five: nREPL</h1>
<hr />
<p>If you want to connect <strong>remotely</strong> via a <strong>REPL</strong> (not the simple socket server from above) to a Clojure runtime you can use nREPL [1]. nREPL is a generic remote service (server and client) into a runnng Clojure runtime and is used for connecting REPLs, IDE integration and programmatic client calls.</p>
<p>Download [2] it to <code>solo-project/lib/tools.nrepl-0.2.13.jar</code>:</p>
<pre><code>solo-project/lib$ wget http://central.maven.org/maven2/org/clojure/tools.nrepl/0.2.13/tools.nrepl-0.2.13.jar
</code></pre>
<p>As with Swank we start the nREPL server and a REPL for local use (note that the socket is opened on <code>0.0.0.0</code> – see above!). </p>
<pre><code>solo-project$ rlwrap java -cp lib/\*:src/clj clojure.main -e "(use 'clojure.tools.nrepl.server) (start-server :port 7888)" -r
#clojure.tools.nrepl.server.Server{:server-socket ... "ServerSocket[addr=/0:0:0:0:0:0:0:0,localport=7888]"] ...
user=&gt; (use 'solo.core)
nil
</code></pre>
<p>Now you can connect from another running Clojure JVM (note that we do not add <code>src/clj</code> to the classpath – so we do not need <em>Solo’s</em> code to connect), connect to the nREPL server and remote-eval some code:</p>
<pre><code>solo-project$ rlwrap java -cp lib/\* clojure.main
Clojure 1.8.0
user=&gt; (use 'clojure.tools.nrepl)
nil
user=&gt; (with-open [conn (connect :port 7888)] (-&gt; (client conn 1000) (message {:op :eval :code "(get-current-loggers)"}) response-values))
;--&gt; [({:logger-name "root", :log-level "DEBUG"})]
</code></pre>
<p>Now set the log-level in the nREPL-server JVM:</p>
<pre><code>user=&gt; (set-log-level! "foo" "INFO")
nil
</code></pre>
<p>And again in the nREPL-client JVM:</p>
<pre><code>user=&gt; (with-open [conn (connect :port 7888)]
  (-&gt; (client conn 1000) (message {:op :eval :code "(get-current-loggers)"})
  response-values))

[({:logger-name "root", :log-level "DEBUG"} {:logger-name "foo", :log-level "INFO"})]
</code></pre>
<p>Since we will be using nREPL for <em>Solo</em> from now on, we use a separate namespace <code>solo.nrepl</code> in <code>solo/nrepl.clj</code> to put the related code there.</p>
<p>Besides directly using <code>clojure.tools.nrepl.client</code> there are other ways to connect to an nREPL server:</p>
<ul>
  <li>
  <p><strong>Counterclockwise</strong> [3]: an Eclipse Plugin for Clojure development</p></li>
  <li>
  <p><strong>Emacs/cider</strong> [4]: use cider/nREPL this instead of SLIME/Swank</p></li>
  <li>
  <p><strong>Leiningen</strong> [5]: a build tool (see next step)</p></li>
</ul>
<p>[1] <a href="https://github.com/clojure/tools.nrepl">https://github.com/clojure/tools.nrepl</a><br />[2] <a href="http://central.maven.org/maven2/org/clojure/tools.nrepl/0.2.13/tools.nrepl-0.2.13.jar">http://central.maven.org/maven2/org/clojure/tools.nrepl/0.2.13/tools.nrepl-0.2.13.jar</a><br />[3] <a href="http://doc.ccw-ide.org/">http://doc.ccw-ide.org/</a><br />[4] <a href="https://cider.readthedocs.io/en/latest/">https://cider.readthedocs.io/en/latest/</a><br />[5] <a href="https://leiningen.org/">https://leiningen.org/</a> </p>
<h2><a href="#jump-start-nrepl" name="jump-start-nrepl"></a>Jump-start nREPL</h2>
<p>Now we want to jump-start the nREPL server (just as we started the Swank server in step four above) so we have remote access to the application.</p>
<p>So let’s change <code>src/clj/solo/jumpstart.clj</code> to:</p>
<pre><code>(ns solo.jumpstart
  (:require [solo.nrepl :as nrepl]
            [solo.core]))

(defn jumpstart []
  (println "solo.jumpstart/jumpstart: starting up:")
  (nrepl/start-server)
  (println "solo.jumpstart/jumpstart: done."))
</code></pre>
<p>We switched from jump-starting <em>Swank</em> to nREPL. You can jump-start both if you like. But nREPL gives you all options and we’ll be using it for programmatic access rather than talking to <em>Solo</em> through an interactive shell session.</p>
<p>So you use Jetty-Runner again:</p>
<pre><code>solo-project$ java \
              -Dlog4j.debug=true -Dlog4j.configuration=file:log4j.properties \
              -Dclojure.server.repl="{:server-daemon false :port 5555 :accept clojure.core.server/repl}" \
              -jar lib/jetty-runner-9.4.9.v20180320.jar \
              --jar jumpstart.jar \
              --lib lib/ \
              --classes src/clj \
              jetty-log4j-test-webapp-1.0-SNAPSHOT.war
</code></pre>
<p>And get log-levels via <em>Netcat</em>. Note that this time we do not need to load namespace <code>solo.core</code> via <code>(use 'solo.core)</code> since we’ve put that into <code>src/clj/solo/jumpstart.clj</code>:</p>
<pre><code>solo-project$ echo "(solo.core/get-current-loggers)" | nc 127.0.0.1 5555
</code></pre>
<p>And of course we can use nREPL client:</p>
<pre><code>solo-project$ rlwrap java -cp lib/\* clojure.main
Clojure 1.8.0
user=&gt; (use 'clojure.tools.nrepl)
nil
user=&gt; (with-open [conn (connect :port 7888)] (-&gt; (client conn 1000) (message {:op :eval :code "(solo.core/get-current-loggers)"}) response-values))
</code></pre>
<hr />
<h1><a href="#step-six-leiningen-codox-marginalia" name="step-six-leiningen-codox-marginalia"></a>Step Six: Leiningen, Codox, Marginalia</h1>
<hr />
<p>Up to now we have been downloading JARs from Maven Central and Clojars and put together the classpath by hand. Now we want to use a build tool for that.</p>
<p>Leiningen [1] is an extendable task executor with dependency resolution. We want to use it to setup a project (“scafolding”), to build, run and test the code. Finally we use it to package, release and deploy our application.</p>
<p>First you have to install Leiningen (see [1]).</p>
<p>Now we use <code>lein new</code> to setup a project. We execute this <strong>in</strong> directory <code>solo-project/</code> (use branch <code>step-five</code> to see these changes):</p>
<pre><code>solo-project$ lein new solo --to-dir .
</code></pre>
<p><strong>Note:</strong> This is a little silly – we could have just created and  filled <code>project.clj</code> and <code>solo-project/test/solo/core_test.clj</code>, but  I wanted to show how to set up a project with Leiningen. Usually you  do this when you do not have an existing project structure to start  with.</p>
<p>This will create some new directories &amp; files:</p>
<pre><code>CHANGELOG.md
LICENSE
README.md
doc/intro.md
project.clj
src/solo/core.clj
test/solo/core_test.clj
</code></pre>
<p>We delete <code>rm -rf src/solo/</code> (we already have the Clojure sources below <code>solo-project/src/clj/solo/</code>) and fix <code>project.clj</code>:</p>
<pre><code>(defproject solo "0.1.0-SNAPSHOT"
  :source-paths ["src/clj"]
  :resource-paths ["lib/clojure-1.8.0.jar" "lib/log4j-1.2.17.jar"])
</code></pre>
<p><strong>Note:</strong> I put the <em>Solo</em> Clojure sources below  <code>solo-project/src/clj/solo/</code> and not below <code>solo-project/src/solo/</code>  (where Leiningen puts them), because later on we will also have  ClojureScript sources and they will go to  <code>solo-project/src/cljs/solo/</code>.</p>
<p>And we fix our first tests in <code>solo-project/test/solo/core_test.clj</code>:</p>
<pre><code>(ns solo.core-test
  (:require [clojure.test :refer :all]
            [solo.core :refer :all]))

(deftest a-test
  (testing "Testing solo.core"
    (is (= [{:logger-name "root", :log-level "DEBUG"}]
           (get-current-loggers)))
    (is (= [{:logger-name "root", :log-level "DEBUG"}
            {:logger-name "foo", :log-level "INFO"}]
           (do ;; mutator!
             (set-log-level! "foo" "INFO")
             (get-current-loggers))))))
</code></pre>
<p>And test:</p>
<pre><code>solo-project$ lein test
lein test solo.core-test

Ran 1 tests containing 2 assertions.
0 failures, 0 errors.
</code></pre>
<p><strong>Dependencies</strong></p>
<p>Instead of supplying the JARs ourselves via <code>:resource-paths</code> we can use Leiningen to do that for us via <code>:dependencies</code>. Change <code>solo-project/project.clj</code> to:</p>
<pre><code>(defproject solo "0.1.0-SNAPSHOT"
  :source-paths ["src/clj"]
  :dependencies [[org.clojure/clojure "1.8.0"]
                 [log4j/log4j "1.2.17"]])
</code></pre>
<p>And run the tests again:</p>
<pre><code>lein test
</code></pre>
<p>Leiningen will <strong>download</strong> the JARs to <code>~/.m2/repo/</code> (your default local <em>Maven</em> <em>Repository</em> – eventhough we’re not using Maven!) so you’ll need an internet connection for this to work.</p>
<p><strong>Using Leiningen</strong></p>
<p>You can use Leiningen to run the examples from above (steps zero through five) but this time Leiningen will put together the classpath for us.</p>
<ul>
  <li>
    <p><strong>rlwrap &amp; (n)REPL</strong>: the <code>repl</code> task starts an nREPL server and the  local REPL (on your tty). Note that we’re using the Leiningen  built-in nREPL support and not <code>solo.nrepl</code> here (use <code>lein help
  repl</code> for help):</p>
    <pre><code>solo-project$ rlwrap lein repl :start :host 0.0.0.0 :port 7888
nREPL server started on port 7888 on host 0.0.0.0 - nrepl://0.0.0.0:7888
REPL-y 0.3.7, nREPL 0.2.12
Clojure 1.8.0
Java HotSpot(TM) Client VM 1.8.0-ea-b116
    Docs: (doc function-name-here)
          (find-doc "part-of-name-here")
  Source: (source function-name-here)
 Javadoc: (javadoc java-object-or-class-here)
    Exit: Control+D or (exit) or (quit)
 Results: Stored in vars *1, *2, *3, an exception in *e
user=&gt; (use 'solo.core)
nil
user=&gt; (set-log-level! "foo" "INFO")
nil
user=&gt; (get-current-loggers)
({:logger-name "root", :log-level "DEBUG"} {:logger-name "foo", :log-level "INFO"})
</code></pre>
  </li>
  <li>
    <p><strong>rlwrap/nREPL client</strong>: since Leiningen has nREPL server &amp;  <strong>client</strong> built-in, you can use <code>repl :connect</code> to start a REPL  that is connected remotely to the nREPL server port 7888 from above  (so you’re running two Leiningen JVMs at the same time for  this). Note that you don’t even need the git workspace  (i.e. <code>project.clj</code>) for this – you just need Leiningen.</p>
    <pre><code>$ rlwrap lein repl :connect 7888
Connecting to nREPL at 127.0.0.1:7888
REPL-y 0.3.7, nREPL 0.2.12
Clojure 1.8.0
Java HotSpot(TM) Client VM 1.8.0-ea-b116
    Docs: (doc function-name-here)
          (find-doc "part-of-name-here")
  Source: (source function-name-here)
 Javadoc: (javadoc java-object-or-class-here)
    Exit: Control+D or (exit) or (quit)
 Results: Stored in vars *1, *2, *3, an exception in *e

user=&gt; (.println System/out "foo")
nil
user=&gt; (get-current-loggers)
({:logger-name "root", :log-level "DEBUG"} {:logger-name "foo", :log-level "INFO"})
</code></pre>
  </li>
  <li>
    <p><strong>Swank plugin</strong>: <code>lein-swank</code> [2] is a (deprecated) Leiningen  plugin (for development) that you can put into <code>project.clj</code>:</p>
    <pre><code>(defproject solo "0.1.0-SNAPSHOT"
  :source-paths ["src/clj"]
  :dependencies [[org.clojure/clojure "1.8.0"]
                 [log4j/log4j "1.2.17"]]
  :plugins [[lein-swank "1.4.5"] ])
</code></pre>
    <p>Now you can run the <code>swank</code> task:</p>
    <pre><code>solo-project$ lein swank 4005 0.0.0.0
Listening for transport dt_socket at address: 39371
Connection opened on 0.0.0.0 port 4005.
</code></pre>
  </li>
  <li>
    <p><strong>solo.swank</strong>: Since we want to “use Swank in production” (as part  of our application without Leiningen and the Swank plugin), we add  <code>[swank-clojure/swank-clojure "1.4.3"]</code> to the <code>:dependencies</code>:</p>
    <pre><code>(defproject solo "0.1.0-SNAPSHOT"
  :source-paths ["src/clj"]
  :dependencies [[org.clojure/clojure "1.8.0"]
                 [log4j/log4j "1.2.17"]
                 [swank-clojure/swank-clojure "1.4.3"]]
  :plugins [[lein-swank "1.4.5"] ])
</code></pre>
    <p>Now we use the <code>run</code> task to execute <code>-main</code> function in <code>solo-project/src/clj/solo/swank.clj</code> which start the swank server – like this:</p>
    <pre><code>solo-project$ lein run -m solo.swank
</code></pre>
  </li>
  <li>
    <p><strong>solo.nrepl</strong>: And the same thing for nREPL server:</p>
    <pre><code>solo-project$ lein run -m solo.nrepl
Starting nREPL server on {:port 7888, :host "0.0.0.0"} ...
Started nREPL server on {:port 7888, :host "0.0.0.0"}.
</code></pre>
  </li>
</ul>
<p><strong>Leiningen Build</strong></p>
<p>I’ll encapsulate the builds (<code>make-jumpstart</code> and <code>make-doc</code>) of several target artifacts in <code>:alias</code> and <code>:profile</code> entries. The <code>project.clj</code> now looks something like this:</p>
<pre><code>(defproject solo "0.1.0-SNAPSHOT"

  :source-paths ["src/clj"]
  :resource-paths ["resources"]
  :target-path "target/%s/"

  :dependencies [[org.clojure/clojure "1.8.0"]
                 [swank-clojure/swank-clojure "1.4.3"]
                 [org.clojure/tools.nrepl "0.2.12"]
                 [log4j/log4j "1.2.17"]
                 [javax.servlet/javax.servlet-api "3.1.0"]]

  :plugins [[lein-swank "1.4.5"]
            [lein-codox "0.10.3"]
            [lein-marginalia "0.9.1"]]

  :aliases {"make-jumpstart" ["with-profile" "+make-jumpstart" "do" ["clean"] "jar"]

            "make-doc" ["with-profile" "+make-doc" "do"
                        ["clean"]
                        ["codox"]
                        ["marg"
                         "-d" "resources/public/generated-doc/"
                         "-f" "solo-source.html"
                         "src/clj"
                         "jumpstart/src"]]}

  :codox {:metadata {:doc/format :markdown}
          :doc-files ["doc/intro.md", "README.md"]
          :output-path "resources/public/generated-doc/"}

  :profiles {:make-jumpstart {:resource-paths ^:replace ["jumpstart/resources"]
                              :aot [solo.jumpstart.servlet_container_initializer]
                              :source-paths ^:replace ["jumpstart/src"]}

             :make-doc {:source-paths ["jumpstart/src"]
                        :clean-targets ^{:protect false} ["resources/public/generated-doc"]}})
</code></pre>
<p><strong>Building jumpstart.jar</strong></p>
<p>You can use Leiningen to build the <code>jumpstart.jar</code> (instead of <code>solo-project/scripts/make-jumpstart-jar.sh</code>).</p>
<p>And build:</p>
<pre><code>solo-project$ lein make-jumpstart &amp;&amp; \
              cp target/provided+make-jumpstart/solo-0.1.0-SNAPSHOT.jar ./jumpstart.jar
</code></pre>
<p><strong>Building Documentation from Clojure Sources and Markdown</strong></p>
<p>We use Codox [3] to generate API documenation (HTML) from Clojure source code, <code>solo-project/doc/intro.md</code> and <code>solo-project/README.md</code>.</p>
<p>We use Marginalia [4] to convert Clojure source into one big HTML with a two-column layout with comments/doc-strings and Clojure code.</p>
<p>In this case we generate the documenation into <code>resources/public/generated-doc/</code>. So this is at “development time” – <strong>not</strong> <strong>compile-time</strong>. At compile-time we include the generated documentation as <em>static</em> <em>content</em> and package it into the JAR or WAR. Later we will deliver the HTML files to end users via <em>Solo’s</em> web GUI.</p>
<p>So after running <code>lein make-doc</code> you will usually commit the generated files into your git repo.</p>
<p><strong>Building solo-module.jar</strong></p>
<p>Now we have to build the JAR, that contains <em>Solo’s</em> core logic and all the classes that are needed to run <em>Solo’s</em> backend. This is not a web-application. It’s just the backend that we will talk to via nREPL client.</p>
<pre><code>solo-project$ lein make-module-jar &amp;&amp; \
              cp target/uberjar/solo-0.1.0-SNAPSHOT-standalone.jar ./solo-module.jar
</code></pre>
<p>This build/<code>project.clj</code> is a little trickier (not shown here) than the ones above. We have to make sure, that we <strong>exclude</strong> log4j and the servlet API from <code>solo-module.jar</code>. Rather than <strong>excluding</strong> JARs when building this target, I like to <strong>include</strong> <strong>explicitly</strong> only the ones that I really need.</p>
<p>Again you may deploy <code>solo-module.jar</code> and <code>jumpstart.jar</code> to an application server (see above) and use <code>lein repl :connect</code> to talk to <em>Solo</em>.</p>
<h2><a href="#deployment-into-production" name="deployment-into-production"></a>Deployment into Production</h2>
<p><strong>TBD:</strong> differences to step four</p>
<p>[1] <a href="https://leiningen.org/">https://leiningen.org/</a><br />[2] <a href="https://github.com/technomancy/swank-clojure">https://github.com/technomancy/swank-clojure</a><br />[3] <a href="https://github.com/weavejester/codox">https://github.com/weavejester/codox</a><br />[4] <a href="https://github.com/gdeer81/marginalia">https://github.com/gdeer81/marginalia</a> </p>
<hr />
<h1><a href="#step-seven-jetty-http-kit-ring-compojure-hiccup-solo-web" name="step-seven-jetty-http-kit-ring-compojure-hiccup-solo-web"></a>Step Seven: Jetty, http-kit, Ring, Compojure, Hiccup, solo.web</h1>
<hr />
<p>By now we have an interactive REPL-access to the application via nREPL-server which we have jump-started via <em>Solo</em>. We can query and modify the log4j loggers of the Java host-application at runtime.</p>
<p>It’s time to build our browser-based GUI for <em>Solo</em>.</p>
<p>First we will build an old-style web-app: it will receive HTTP-GET requests (for <em>queries</em>) and HTTP-POST requests (for <em>modifications</em>) – so called <em>POST-backs</em>.</p>
<p>For each request the web-app will return a <strong>complete</strong> <strong>HTML-page</strong> which is then rendered by the browser. With each (GET/POST) request the browser will <strong>navigate</strong> (thus it’s not an SPA).</p>
<p>We’ll be using:</p>
<ul>
  <li>
  <p><strong>Jetty, http-kit</strong>: Jetty [1] and http-kit [2] are web-servers that  support <em>Java Servlets</em> [3] (**TODO**: really? check that for  http-kit). We will use them for development (and optionally for  production). You can use either of them.</p></li>
  <li>
  <p><strong>Ring</strong>: Ring [4] supplies the integration into the <em>Java Servlet  Layer</em>. It receives requests and must deliver responses in the way  the Java Servlet Spec dictates.</p></li>
</ul>
<p>Ring translates the requests into Clojure function calls (which may  well be your functions) and will pass in the “transformed” Servlet  request as a Clojure map (**pure data**! No statefull streams … if  you’re not asking for it). In the end it will translate the  function’s response – your function! – (also pure data, usually a  map) back into the Servlet API response stream (incl. HTTP-header,  HTTP-status, etc.).</p>
<p>For development Ring comes with Jetty included. For production we  will build a web-app WAR and use Ring’s servlet. We can then deploy  that WAR into JBoss/Wildfly/Websphere.</p>
<ul>
  <li><strong>Compojure</strong>: Compojure [5] lets you assign/map HTTP-requests  (e.g. URLs) to functions. The request URL is part of the  Ring-request-map and we can express the mapping to functions in  several ways (see below). This mapping is called <em>routing</em>.</li>
</ul>
<p>So our (pure) functions get called by/through Ring/Compojure and they have to return text/HTML. We could just concat the HTML markup into a <code>String</code> and return that. That would work, but it would be no fun.</p>
<ul>
  <li><strong>Hiccup</strong>: Hiccup [6] is a templating lib that lets you use  Clojure’s built-in data-types (maps, lists, vectors, keywords,  strings) to describe the <strong>structure</strong> of an HTML document. It will  then create a <code>String</code> containing the HTML markup that corresponds  to that structure.</li>
</ul>
<p>We’ll put all of the web-app related Clojure sources into the namespace <code>solo.web</code>.</p>
<p>[1] <a href="https://www.eclipse.org/jetty/">https://www.eclipse.org/jetty/</a><br />[2] <a href="http://www.http-kit.org/">http://www.http-kit.org/</a><br />[3] <a href="https://en.wikipedia.org/wiki/Java_servlet">https://en.wikipedia.org/wiki/Java_servlet</a><br />[4] <a href="https://github.com/ring-clojure/ring">https://github.com/ring-clojure/ring</a><br />[5] <a href="https://github.com/weavejester/compojure">https://github.com/weavejester/compojure</a><br />[6] <a href="https://github.com/weavejester/hiccup">https://github.com/weavejester/hiccup</a> </p>
<h2><a href="#ring" name="ring"></a>Ring</h2>
<p>Add the dependencies for Ring:</p>
<pre><code>  :dependencies [,,,[ring/ring-core "1.6.3"]
                 [ring/ring-jetty-adapter "1.6.3"]]
</code></pre>
<p>Let’s run a “Hello World” example. Since we will not use this code in <em>Solo</em> I put it in <code>solo-project/scripts/script-two.clj</code>:</p>
<pre><code>(use 'ring.adapter.jetty)

(defn handler [ring-req]
  {:status 200
   :headers {"Content-Type" "text/html"}
   :body "&lt;h1&gt;Hello World&lt;/h1&gt;"})

(run-jetty handler
           {:port 3000
            :host "0.0.0.0"})
</code></pre>
<p>And run:</p>
<pre><code>solo-project$ lein run -m clojure.main scripts/script-two.clj
Java HotSpot(TM) Client VM warning: TieredCompilation is disabled in this release.
LOADING ~/.lein/profiles.d/user.clj
Java HotSpot(TM) Client VM warning: TieredCompilation is disabled in this release.
2018-04-10 17:47:56.417:INFO::main: Logging initialized @4174ms
2018-04-10 17:47:56.644:INFO:oejs.Server:main: jetty-9.2.21.v20170120
2018-04-10 17:47:56.724:INFO:oejs.ServerConnector:main: Started ServerConnector@70dd40{HTTP/1.1}{0.0.0.0:3000}
2018-04-10 17:47:56.727:INFO:oejs.Server:main: Started @4483ms
</code></pre>
<p>Now point your browser to <a href="http://localhost:3000/">http://localhost:3000/</a> or just use <code>curl</code>:</p>
<pre><code>solo-project$ curl http://localhost:3000
&lt;h1&gt;Hello World&lt;/h1&gt;
</code></pre>
<p>To make life a little easier we use the <code>lein-ring</code> plugin for development, which can start a jetty server for us and hook our <em>top-level</em> Ring handler <code>solo.web/app</code> in.</p>
<p>Put this into <code>project.clj</code>:</p>
<pre><code>  :plugins [,,,[lein-ring "0.12.4"]]
  :ring {:handler solo.web/app
         :nrepl {:start? true
                 :port 9998}}
</code></pre>
<p>And for a start the following code goes into <code>solo-project/src/clj/solo/web.clj</code> (note that there is no other namespace required!).</p>
<pre><code>(ns solo.web)

(defn handler [ring-req]
  {:status 200
   :headers {"Content-Type" "text/html"}
   :body "Hello World!"})

(defn app [ring-map]
  (handler ring-map))
</code></pre>
<p>And run:</p>
<pre><code>solo-project$ lein ring server-headless
2018-04-10 21:19:51.479:INFO::main: Logging initialized @4722ms
Started nREPL server on port 9998
2018-04-10 21:20:02.041:INFO:oejs.Server:main: jetty-9.2.21.v20170120
2018-04-10 21:20:02.124:INFO:oejs.ServerConnector:main: Started ServerConnector@7d1c1{HTTP/1.1}{0.0.0.0:3000}
2018-04-10 21:20:02.128:INFO:oejs.Server:main: Started @15371ms
Started server on port 3000
</code></pre>
<p>You can now go to <a href="http://localhost:3000/">http://localhost:3000/</a> and connect to the <strong>nREPL</strong> server at <code>9998</code>.</p>
<h2><a href="#compojure" name="compojure"></a>Compojure</h2>
<p>Before we can use Compojure we have to add the dependency <code>[compojure "1.6.0"]</code>:</p>
<pre><code>  :dependencies [,,,[compojure "1.6.0"]]
</code></pre>
<p>With Compojure we can define routes for HTTP requests (<code>GET</code> and <code>POST</code> in our case) and can delegate to functions to do the real work (see below).</p>
<pre><code>(defroutes main-routes
  (GET "/" req "hello world")
  (POST "/set-log-level" req
    ;; something with req
    (redirect "/"))
  (POST "/update-loggers" req
    ;; something with req
    (redirect "/"))
  (route/resources "/")
  (route/not-found "Page not found"))

(def app (handler/site #'main-routes))
</code></pre>
<h2><a href="#hiccup" name="hiccup"></a>Hiccup</h2>
<p>Before we can use Hiccup we have to add the dependency <code>[hiccup "1.0.5"]</code>:</p>
<pre><code>  :dependencies [,,,[hiccup "1.0.5"]]
</code></pre>
<p>With Hiccup we convert Clojure data structures into HTML markup. This is the function which will return the <strong>complete</strong> <strong>HTML-page</strong> (see above).</p>
<pre><code>(defn the-page [filter-reg-ex]
  (let [loggers (get-current-loggers filter-reg-ex)]
    (hp/html5
     [:head
      (hp/include-css "solo.css")]
     [:body
      (set-log-level-form filter-reg-ex)
      (loggers-form loggers filter-reg-ex)])))
</code></pre>
<h2><a href="#solo-web" name="solo-web"></a>solo.web</h2>
<p>Our first application will have only one page (but it’s <strong>not</strong> a SPA ;-). The page (<code>GET "/"</code>) will show a table with all current log4j loggers and their log-level (an input field). </p>
<p>You can change the log-level entries and use a <code>GO</code> button to submit the data to <code>(POST "/update-loggers")</code>.</p>
<p>For <code>POST</code>-requests <code>solo.web</code> returns a <code>(redirect "/")</code> so that you can use the browser’s page-reload for updating the page after a submit (if we were just returning the page-content for the <code>POST</code>-request the browser would ask us if we want to re-send the <code>POST</code>-request when doing a page-reload after a submit).</p>
<p>So here’ the code for reference:</p>
<pre><code>(ns solo.web
  (:use compojure.core)
  (:require [solo.core :as core]
            [ring.util.response :use redirect]
            [compojure.route :as route]
            [compojure.handler :as handler]
            [hiccup.page :as hp]
            [hiccup.form :as hf]))

(defn loggers-form [loggers]
  (hf/form-to
   [:post "/update-loggers"]
   [:table
    [:tr [:th "LOGGER"] [:th "LEVEL"]]
    (for [{:keys [logger-name log-level]} loggers]
      [:tr
       [:td logger-name]
       [:td (hf/text-field logger-name log-level)]])]
   (hf/submit-button "GO")))

(defn the-page []
  (let [loggers (core/get-current-loggers)]
    (hp/html5
     [:head
      (hp/include-css "solo.css")]
     [:body
      (loggers-form loggers)])))

(defroutes main-routes
  (GET "/" _ (the-page))
  (POST "/update-loggers" req
    (doseq [[logger level] (:params req)]
      (core/set-log-level! (name logger) level))
    (redirect "/"))
  (route/resources "/")
  (route/not-found "Page not found"))

(def app (handler/site main-routes))
</code></pre>
<p>I put a <code>:main solo.jetty</code> into the <code>:repl</code> profile in <code>project.clj</code>. So we can do this now (notice that <code>solo.jetty</code> is loaded automatically):</p>
<pre><code>solo-project$ lein repl
2018-04-14 06:45:27.199:INFO::main: Logging initialized @2975ms
nREPL server started on port 41574 on host 127.0.0.1 - nrepl://127.0.0.1:41574
REPL-y 0.3.7, nREPL 0.2.12
Clojure 1.8.0
Java HotSpot(TM) Client VM 1.8.0-ea-b116
    Docs: (doc function-name-here)
          (find-doc "part-of-name-here")
  Source: (source function-name-here)
 Javadoc: (javadoc java-object-or-class-here)
    Exit: Control+D or (exit) or (quit)
 Results: Stored in vars *1, *2, *3, an exception in *e

solo.jetty=&gt; (-main)
2018-04-14 06:46:03.661:INFO:oejs.Server:nREPL-worker-0: jetty-9.2.21.v20170120
2018-04-14 06:46:03.741:INFO:oejs.ServerConnector:nREPL-worker-0: Started ServerConnector@d59b83{HTTP/1.1}{0.0.0.0:3000}
2018-04-14 06:46:03.741:INFO:oejs.Server:nREPL-worker-0: Started @39517ms
#object[org.eclipse.jetty.server.Server 0x1b62888 "org.eclipse.jetty.server.Server@1b62888"]
</code></pre>
<p>Now go to <code>http://localhost:3000/</code>. You should see just the button. Now do:</p>
<pre><code>solo.jetty=&gt; (solo.core/set-log-level! "foo.bar" "INFO")
nil
solo.jetty=&gt; 
</code></pre>
<p>And reload the page. You should see the logger.</p>
<p>There are some things wrong with this solution:</p>
<ul>
  <li>we cannot create new loggers via the web-gui (just change existing ones)</li>
  <li>when there are a lot of loggers, the list will become long and for  very long lists the <code>POST</code>-request will become too large for  processing.</li>
</ul>
<p>So I’ve added a few things to <code>web.clj</code>:</p>
<ul>
  <li>a drop down list for log-levels (instead of entering a text)
    <pre><code>(hf/drop-down logger-name log-levels log-level)
</code></pre>
  </li>
</ul>
<p>The set of known log-levels contains two <em>special</em> elements (taken  care of in <code>get-current-loggers</code>): <code>"UNKNOWN!"</code> for cases where we  find a log-level in log4j that we don’t know and <code>"NOT-SET!"</code> for  loggers that have no log-level set. These loggers exist because Java  classes usually use <code>static final Logger</code> so the lookup is done at  class-initialization time which causes the logger being created even  if there is not log-level configured for the concrete logger.</p>
<p>When any of these two log-level is selected for any logger, the  logger will not have its log-level set (see <code>set-log-level?</code>).</p>
<ul>
  <li>
    <p>enter new loggers (in a separate <code>form</code> element).</p>
    <pre><code>(defn set-log-level-form [{:keys [filter-reg-ex hide]}]
  (hf/form-to
   {:id "new-logger"}
   [:post "/set-log-level"]
   (hf/hidden-field " FILTER" filter-reg-ex)
   (hf/hidden-field " HIDE" (str hide))
   (hf/label :logger "LOGGER:")
   (hf/text-field {:placeholder "Logger Name"} :logger)
   [:span {:style "padding:1em;"}]
   (hf/label :level " LEVEL:")
   (hf/drop-down :level log-levels "INFO")
   [:span {:style "padding:1em;"}]
   (hf/submit-button "SET LOG-LEVEL")))
</code></pre>
  </li>
  <li>
    <p>filter and sort loggers: the filter is a reg-ex which is used to  <code>re-find</code>-filter the loggers by their names. In addition you can  select to <em>hide</em> loggers that have log-level <code>"NOT-SET!"</code>:</p>
    <pre><code>(defn get-current-loggers [{:keys [filter-reg-ex hide]}]
  (-&gt;&gt; (core/get-current-loggers)
       (map
        (fn [{:keys [logger-name log-level] :as logger}]
          (cond
            (= "" log-level) (assoc logger :log-level "NOT-SET!")
            (not (log-levels log-level)) (assoc logger :log-level "UNKNOWN!")
            :else logger)))
       (filter 
        #(and (re-find filter-reg-ex (:logger-name %))
              (if hide
                (not= "NOT-SET!" (:log-level %))
                true)))
       (sort-by :logger-name)))
</code></pre>
  </li>
</ul>
<p>The filter can be entered via a textfield which is part of the  <code>loggers-form</code> for entering the log-levels:</p>
<pre><code>    (defn loggers-form [loggers {:keys [filter-reg-ex hide]}]
      (hf/form-to
       [:post "/update-loggers"]
       [:table#loggers
        [:tr
         [:th "LOGGER"
          (hf/text-field
           {:placeholder "Filter Reg-Ex"
            :style "float: right;"}
           " FILTER" filter-reg-ex)]
         [:th "LEVEL"
          [:span {:style "float: right;"} 
           (hf/label :hide " Hide NOT-SET!:")
           (hf/check-box " HIDE" hide)]]]
        (for [{:keys [logger-name log-level]} loggers]
          [:tr
           [:td logger-name]
           [:td (hf/drop-down logger-name log-levels log-level)]])]
       (hf/submit-button "SET LOG-LEVELS")))
</code></pre>
<ul>
  <li>
  <p><strong>TODO</strong>: paging</p></li>
  <li>
  <p><strong>TODO</strong>: submit only changed entries</p></li>
</ul>
<h2><a href="#testing" name="testing"></a>Testing</h2>
<p><strong>TODO</strong>: how to test solo.web?</p>
<h2><a href="#options-for-deployment" name="options-for-deployment"></a>Options for Deployment</h2>
<p>We have (at least) two options:</p>
<ul>
  <li><strong>WAR deployment</strong>: we build a WAR containing all of <em>Solo’s</em>  dependencies (except log4j) incl. a <code>web.xml</code>. This can then be  deployed side-by-side with the JEE host-application [1].</li>
</ul>
<p>We’ll need no jump-starter in this case, since the <code>web.xml</code> will  register a Ring servlet with the web-container which will  initialize/start the servlet and then wait for incoming requests.</p>
<p>If you like, you can use the initialization phase of the web-app to  start an nREPL server.</p>
<ul>
  <li><strong>Module Deployment</strong>: we deploy only <em>Solo’s</em> “backend”-JAR  (<code>solo.core</code> and <code>solo.nrepl</code> and their dependencies, maybe  <code>solo.swank</code> if you like) as <em>modules</em> (see above) to the app-server  (or web-server; see below) running the host-application.</li>
</ul>
<p>In this case we need to jump-start <code>solo.repl</code> so that we can access  it remotely (remember – it’s not a web-app in this case).</p>
<p>Then we use Jetty (in a <strong>separate</strong> JVM; or you could use any  web-server even the one running the <em>Solo</em> backend) to host  <code>solo.web</code> and use nREPL clients for delegating calls from  <code>solo.web</code> to <code>solo.core</code> functions remotely to the nREPL server.</p>
<p>Now we have a distributed application.</p>
<p>This second options makes sense if you want to work on <em>Solo’s</em> web-layer (which we will in step eight++) and you may have to change dependencies. In this case, you can do this without re-starting <code>solo.core</code> (which is more stable in terms of changes that you may make to the code) and you need not re-start the app-server which can be time-consuming.</p>
<p>This setup will work for development also: you can run <code>solo.web</code> in your Leiningen dev JVM and call the <em>production</em> <code>solo.core</code> via nREPL – nice!</p>
<p>[1] <strong>TODO:</strong> Note: we have to look at classloaders since <em>Solo</em> only works, if it accesses the <strong>same</strong> log4j classes as the host-application does.</p>
<h2><a href="#war-deployment" name="war-deployment"></a>WAR Deployment</h2>
<p>In <code>solo-project/src/clj/solo/webapp.clj</code> I put the code for our <em>statefull</em> web-app. On startup the web-app will start an nREPL server on port <code>7888</code> and <code>.close</code> it when the web-app shuts down.</p>
<p>Build:</p>
<pre><code>solo-project$ lein make-web-war
Created [...]/solo-project/target/make-web-war+web-deps+uberjar/solo-web.war
</code></pre>
<p>Here we use Jetty-Runner to run <em>Solo</em> without a host-application. That’s why we have to add log4j JAR.</p>
<pre><code>solo-project$ java -Dlog4j.configuration=file:log4j.properties -Dlog4j.debug=true \
                   -jar lib/jetty-runner-9.4.9.v20180320.jar \
                   --jar lib/log4j-1.2.17.jar \
                   target/make-web-war+web-deps+uberjar/solo-web.war
</code></pre>
<p>Then go to <a href="http://localhost:8080/">http://localhost:8080/</a></p>
<pre><code>lynx -nopause http://localhost:8080/
</code></pre>
<p><strong>Note:</strong></p>
<ul>
  <li>
  <p>the <em>stand-alone</em> deployment is for testing only. Since there is no  JEE host-application using log4j, there is no sense in setting any  log-levels.</p></li>
  <li>
  <p>when you deploy the <em>production-WAR</em> you must make sure that the  <em>Solo</em> web-app is loaded such that the classloader that loads <em>Solo</em>  can <em>see</em> the log4j-classes of the host-application.</p></li>
</ul>
<p>This usually means that the host-application must be a JEE  application (EAR) containing one ore more web-applications  (WAR). The log4j JAR should be included in EAR-<code>/lib</code>. <em>Solo</em> is  then deployed into the same server and will thus see the same log4j  classes.</p>
<p>If the log4j JAR is contained in one of the WARs within the JEE app,  you won’t be able to set the log-levels for that web-app. In this  case you have to use the <em>module deployment</em> (see below).</p>
<ul>
  <li>For JBoss/Wildfly you can use the admin console to upload  <code>solo-web.war</code> into JBoss’ content repository and <em>assign</em> it to  your host-applcation’s <em>server</em>. (**TODO**: show jboss-cli  example). Then you can turn <em>Solo</em> on and off just by <em>disable</em> and  <em>enable</em> in the admin console (so no need to <em>unassign</em>/_assign_ for  this). That’s really nice.</li>
</ul>
<p><strong>TODO</strong>: take care of agent thread-pool in <code>destroy</code>!!!!</p>
<ul>
  <li>For IBM WebSphere: <strong>TODO:</strong> show this for JEE app and plain  web-app.</li>
</ul>
<p><strong>TODO</strong>: make ports configureable (Apache Configuration!?) for nREPL server so that we can deploy to more than one server on the same host at the same time.</p>
<h2><a href="#module-deployment-and-nrepl-access" name="module-deployment-and-nrepl-access"></a>Module Deployment and nREPL Access</h2>
<p>In some cases <em>Solo</em> (i.e. <code>solo.core</code> as part of <code>solo-web.war</code>) may not be able to access the host-application’s log4j classes:</p>
<ul>
  <li>
  <p>when the log4j JAR is contained in the host-application’s WAR rather  than in its EAR-<code>/lib</code> (although this case should be rare and may be  a sign for a broken packaging of the JEE app).</p></li>
  <li>
  <p>when you’re not targeting a JEE app but just a “simple” web-app.</p></li>
</ul>
<p>In these cases you may have a hard time tweaking the web-container’s classloading so that it loads both – <code>solo-web.war</code> and the host-application – with the <strong>same</strong> classloader (for IBM Websphere this is simple though).</p>
<p>So rather than deploying <em>Solo</em> as a (self-contained, complete) web-app we will make some of its namespaces part of the host-application. </p>
<p>You can build an uberjar with <code>solo.core</code>, <code>solo.repl</code> and Clojure and put that as a <em>module</em> into JBoss and bind the module to your profile (**TODO**: Apache Tomcat). Then you need a jump-starter (see above) to jump-start <code>solo.repl</code>.</p>
<p>Build <code>solo-module.jar</code>:</p>
<pre><code>solo-project$ lein make-module-jar &amp;&amp; \
              cp target/uberjar/solo-0.1.0-SNAPSHOT-standalone.jar solo-module.jar
</code></pre>
<p>Build <code>solo-jumpstart.jar</code>:</p>
<pre><code>solo-project$ lein make-jumpstart &amp;&amp; \
              cp target/provided+make-jumpstart/solo-0.1.0-SNAPSHOT.jar solo-jumpstart.jar
</code></pre>
<p>Run:</p>
<pre><code>solo-project$ java -Dlog4j.configuration=file:log4j.properties -Dlog4j.debug=true \
                   -jar lib/jetty-runner-9.4.9.v20180320.jar \
                   ../jetty-and-log4j-example/jetty-log4j-test-webapp/target/jetty-log4j-test-webapp-1.0-SNAPSHOT.war \
                   --jar solo-jumpstart.jar \
                   --jar solo-module.jar
</code></pre>
<p>Now we need <em>Solo</em> web-app to access <em>Solo</em> core.</p>
<p>Build:</p>
<pre><code>solo-project$ lein make-web-jar &amp;&amp; \
              cp target/uberjar/solo-0.1.0-SNAPSHOT-standalone.jar solo-web.jar
</code></pre>
<p>Run:</p>
<pre><code>solo-project$ java -jar solo-web.jar -j 3000 -r 7888
</code></pre>
<p>Now you can go to <code>http://localhost:3000</code> and talk to <em>Solo</em> web-app which will access <em>Solo</em> core via nREPL.</p>
<pre><code>lynx -nopause http://localhost:3000
</code></pre>
<p>And you can go to <code>http://localhost:8080</code> and talk to the jetty-and-log4j-example app which uses log4j.</p>
<hr />
<h1><a href="#step-eight-clojurescript" name="step-eight-clojurescript"></a>Step Eight: clojurescript</h1>
<hr />
<p>For client side logic I use ClojureScript/CLJS [1]. CLJS is a compiled/transpiled language [2] which is very similar to Clojure. CLJS is compiled to JavaScript/JS, the compiler is written in Clojure.</p>
<p>Until now <code>solo.web</code> uses no client-side scripting. All client interaction with the backend is based on HTML-<code>form</code> <em>POST-backs</em>. While we’re introducing client-side scripting we’ll re-structure the logic a little:</p>
<ul>
  <li>
  <p>We publish web-services (<code>/ws/get-current-loggers</code> and  <code>/ws/set-log-level</code>) on the server-side: these will use JSON  (**TODO:** what about EDN?) as message format. That makes it easy to  use these web-services from the browser/CLJS.</p></li>
  <li>
  <p>We consume (i.e. <em>use</em>) these web-services on the client-side: we’ll  use CLJS to (1) retrieve the loggers via <code>/ws/get-current-loggers</code>,  (2) do the filtering/sorting and (3) render the data to the DOM. For  mutation we’ll (4) call <code>/ws/set-log-level</code>.</p></li>
</ul>
<p>So we move most of the MVC-logic away from the server and put it into the client. Not only will the client do the rendering (which it has done before already) but also do <em>smart</em> things like <strong>create</strong> the markup/DOM and do filtering etc. The backend becomes just a thin (technical) proxy/adapter and the bare <em>core</em> <em>logic</em> (<code>solo.core</code>).</p>
<p>[1] <a href="https://clojurescript.org/">https://clojurescript.org/</a> [2] <a href="https://github.com/clojure/clojurescript">https://github.com/clojure/clojurescript</a></p>
<h2><a href="#solo-spa-solo-web-spa" name="solo-spa-solo-web-spa"></a>solo.spa, solo.web.spa</h2>
<p>Before we look into the CLJS sources let’s have a look at the build.</p>
<p><strong>Build</strong></p>
<p>We put the CLJS sources into <code>src/cljs/solo/spa.cljs</code>. You can compile these sources with:</p>
<pre><code>solo-project$ lein make-spa
</code></pre>
<p>This will run the CLJS compiler which produces JavaScript code into <code>resources/public/js/compiled/</code>. You should see something like this:</p>
<pre><code>Compiling ClojureScript...
Compiling ["resources/public/js/compiled/solo-spa.js"] from ["src/cljs"]...
Successfully compiled ["resources/public/js/compiled/solo-spa.js"] in 1.84 seconds.
</code></pre>
<p>The compile/build is configured with some <code>project.clj</code> entries. <code>:cljsbuild</code> defines the build(s) [2]:</p>
<pre><code>  :aliases {,,, "make-spa" ["with-profile" "+spa" "trampoline" "cljsbuild" "once"]}

  :profiles {,,,
             :spa {:plugins [[lein-cljsbuild "1.1.7" :exclusions [[org.clojure/clojure] ]]]

                   :clean-targets ^{:protect false} ["resources/public/js/compiled"
                                                     :target-path]

                   :dependencies [[org.clojure/clojurescript "1.10.238"]
                                  [prismatic/dommy "1.1.0"]]}}

  :cljsbuild {:builds
              [{:id "dev"
                :source-paths ["src/cljs"]

                :compiler {:main solo.spa
                           :asset-path "js/compiled/out"
                           :output-to "resources/public/js/compiled/solo-spa.js"
                           :output-dir "resources/public/js/compiled/out"
                           :source-map-timestamp true}}]}
</code></pre>
<p>The <em>main</em> entry point is <code>solo-spa.js</code> (cf. <code>:output-to
"resources/public/js/compiled/solo-spa.js"</code>). It should look like this:</p>
<pre><code>var CLOSURE_UNCOMPILED_DEFINES = {};
var CLOSURE_NO_DEPS = true;
if(typeof goog == "undefined")
    document.write('&lt;script src="out/assets/goog/base.js"&gt;&lt;/script&gt;');
document.write('&lt;script src="out/assets/goog/deps.js"&gt;&lt;/script&gt;');
document.write('&lt;script src="out/assets/cljs_deps.js"&gt;&lt;/script&gt;');
document.write('&lt;script&gt;if (typeof goog == "undefined")
  console.warn("ClojureScript could not load :main, did you forget to specify :asset-path?");&lt;/script&gt;');
document.write('&lt;script&gt;goog.require("process.env");&lt;/script&gt;');
document.write('&lt;script&gt;goog.require("solo.spa");&lt;/script&gt;');
</code></pre>
<p>It’s a <em>loader</em> script that will pull in all libraries that CLJS and <code>solo.spa</code> depend on and in the end it will <em>load</em> (i.e. <code>require</code>) namespace <code>solo.spa</code> (cf. <code>:main solo.spa</code>) – it’s <strong>not</strong> a function call that “starts your program”, it is just the “loading of your namespace” that has to start-up whatever you want to have started.</p>
<p>Note that the <em>loader</em> uses <code>document.write</code> (so it really <strong>writes</strong> <code>script</code> <strong>elements</strong> into the hosting HTML page while it is loading) to make the <strong>browser</strong> load the JavaScript sources. It does <strong>not</strong> use a JS API to dynamically load JS sources (except for the last two lines that call <code>require</code> function). And some of the referenced JS scrip-files do also use <code>document.write</code>. This makes it difficult to load these JavaScript sources after the hosting HTML page has been loaded initially, because writing to the document after the inital load has completed will wipe-out the current document and do a new page-load so you’ll lose the loading document which is usually not what you’re trying to do.</p>
<p>Many more files are written to <code>resources/public/js/compiled/out/</code> (cf. <code>:output-dir "resources/public/js/compiled/out/*"</code>). CLJS uses the Google Closure compiler [1], so that makes for some of the generated JS files.</p>
<p>[1] <a href="https://developers.google.com/closure/compiler/">https://developers.google.com/closure/compiler/</a> [2] <a href="https://github.com/clojure/clojurescript-site/blob/master/content/reference/compiler-options.adoc">https://github.com/clojure/clojurescript-site/blob/master/content/reference/compiler-options.adoc</a></p>
<p><strong>Hosting HTML Page</strong></p>
<p>We want to run <code>solo.spa</code> in the browser. In order to load the compiled JS into the browser we need a <em>hosting</em> HTML page that contains a <code>&lt;script&gt;</code> element that references the JS file <code>resources/public/js/compiled/solo-spa.js</code>.</p>
<p>You could use a static <code>index.html</code> file and load that via <code>file://</code> or <code>http://</code> URL. Instead we will create the HTML page <strong>dynamically</strong> via <em>Solo’s</em> server side. In <code>src/clj/solo/web/spa.clj</code> you find the web-app that we’ll use for the SPA. It delivers</p>
<ul>
  <li>
    <p>the hosting HTML page at <code>/spa</code>: this loads the JS main module, look  into <code>solo.web.spa/the-page</code></p>
    <pre><code>[:script {:src "out/solo-spa.js" :type "text/javascript"}]
</code></pre>
  </li>
  <li>
    <p>the compiled JS files at <code>/out</code></p>
    <pre><code>(route/resources "/out" {:root "public/js/compiled"})
</code></pre>
  </li>
  <li>
  <p>the web-services at <code>/ws</code></p></li>
</ul>
<p><strong>Note:</strong> Getting the (relative) URLs right can be a little tricky. We load the hosting page at <code>/spa</code> and the load-module <code>solo-spa.js</code> via relative URL at <code>out/solo-spa.js</code> which gives us the URL <code>/out/solo-spa.js</code>. <code>/out</code> is served via <code>(route/resources "/out"
{:root "public/js/compiled"})</code>. <code>route/resources</code> works through the classpath/classloader. And since we have <code>:resource-paths
["resources"]</code> the base-offset/<code>:root</code> is <code>resources/public/js/compiled</code>. So <code>/out/solo-spa.js</code> effectivly points to <code>resources/public/js/compiled/solo-spa.js</code>. Now the <code>src</code>-URLs in <code>solo-spa.js</code> are loaded relative to the containing page. The URLs will all have to prefix <code>:asset-path
"out/assets"</code>. Again <code>out</code> maps to <code>resources/public/js/compiled</code>. So for example <code>src="out/assets/goog/base.js"</code> effectivly points to <code>resources/public/js/compiled/assets/goog/base.js</code>.</p>
<p>All other requests will be delegated to <code>solo.web/app</code>. So you can still use <em>Solo’s</em> CSS files in your SPA and you can even <em>switch</em> to the plain HTML version of <em>Solo</em> just by using a different URL to start.</p>
<p>All this routing is condensed into this (have I mentioned that Clojure source is so <em>dense</em> that it first hurts when you come from other programming languages like – say – Java?!)</p>
<pre><code>(defroutes main-routes
  (GET "/spa" _ (the-page))
  (route/resources "/out" {:root "public/js/compiled"})
  web/app)
</code></pre>
<p><strong>Running Solo SPA</strong></p>
<p>You can run the SPA just the way you ran <em>Solo</em> before. I changed <code>src/clj/solo/jetty.clj</code> so that Jetty now serves the new web-app <code>solo.web.spa/app</code>.</p>
<pre><code>solo-project$ lein run-web-jar -j 3000
</code></pre>
<p><strong>Development</strong></p>
<p>While using <em>Solo</em> SPA you can change the Clojure backend and the CLJS front-end anytime.</p>
<p>You just need to run the CLJS compiler (__incremental__ <strong>build</strong>!) whenever the CLJS sources change and you need nREPL or Swank to talk to the backend. Like this:</p>
<pre><code>solo-project$ lein make-spa-auto
</code></pre>
<p>This runs the following alias. It will start an auto-compile that will just sit there and wait and compile any CLJS source that changes.</p>
<pre><code>"make-spa-auto" ["with-profile" "+spa" "trampoline" "cljsbuild" "auto"]
</code></pre>
<p>And then in a second shell run <em>Solo</em>:</p>
<pre><code>solo-project$ lein run-web-jar -j 3000 -s 4005
</code></pre>
<p>Now you have two running JVMs.</p>
<p>When you change the CLJS source you have to <em>reload</em> the page in the browser after the CLJS compiler has written the updated file. The reload will not (__yet__!) be done for you. Since the reload will wipe the current page/document you will lose any state that your application may have reached (but see below!).</p>
<h2><a href="#solo-rest-solo-client-rest" name="solo-rest-solo-client-rest"></a>solo.rest, solo.client.rest</h2>
<h2><a href="#solo-client" name="solo-client"></a>solo.client</h2>
<hr />
<h1><a href="#step-nine-brepl" name="step-nine-brepl"></a>Step Nine: bREPL</h1>
<hr />
<p>There is one piece missing: we’d like to have a REPL in the browser (just the way we have a REPL in Clojure/JVM) so that we can interact directly with the JavaScript/CLJS environment and the DOM.</p>
<p>There are REPLs that run completly in the browser (“self hosted CLJS REPL”). Here we will use a REPL that reads its input through a Clojure/JVM prompt, compiles the code on-the-fly and then hands over the compiled CLJS to the browser and executes it there.</p>
<p>Since we cannot connect to a server-socket in the browser we make the browser repeatedly <strong>pull</strong> the compiled CLJS from the Clojure/JVM – it’s called <em>long</em> <em>polling</em>.</p>
<p>You run this <em>long</em> <em>polling</em> like this in your CLJS. When this namespace is loaded it will start a browser REPL and connect to the given URL and <em>long</em> <em>poll</em> that URL:</p>
<pre><code>(:require [clojure.browser.repl :as repl])
(defonce conn (repl/connect "http://localhost:9000/repl"))
</code></pre>
<p>Then you need to start the server-side of the browser REPL:</p>
<pre><code>solo-project$ rlwrap lein run-brepl
</code></pre>
<p>This runs this:</p>
<pre><code>"run-brepl" ["with-profile" "+spa" "trampoline" "cljsbuild" "repl-listen"]
</code></pre>
<p>The CLJS plugin will try to open a browser window. You can close that. Then go to <a href="http://localhost:3000/spa">http://localhost:3000/spa</a></p>
<p>Open the development tools in our browser and go to the “networking” section. You should see many <code>GET</code> requests like this</p>
<pre><code>http://localhost:3000/spa
http://localhost:3000/css/solo.css
http://localhost:3000/out/solo-spa.js
http://localhost:3000/out/assets/goog/base.js
[...]
http://localhost:3000/out/assets/solo/spa.js
http://localhost:9000/repl?xpc=[...]
http://localhost:9000/
</code></pre>
<p>After <code>http://localhost:9000/</code> you should see the prompt in the browser REPL JVM (if it does not show up try hitting ENTER once).</p>
<pre><code>solo-project$ rlwrap lein run-brepl
Running ClojureScript REPL, listening on port 9000.
ClojureScript 1.10.238
cljs.user=&gt;
</code></pre>
<p>Now try the following. You should see a pop-up in your browser:</p>
<pre><code>cljs.user=&gt; (js/alert "Don't panic!")
nil
cljs.user=&gt; 
</code></pre>
<p>You have a REPL in your browser.</p>
<p><strong>TODO:</strong> testing clojurescript?</p>
<hr />
<h1><a href="#step-ten-figwheel" name="step-ten-figwheel"></a>Step Ten: figwheel</h1>
<hr />
<p><strong>TODO</strong>: dynamic code reload while preserving your app-state.</p>
<hr />
<h1><a href="#step-eleven-react-reagent-solo-client-reagent" name="step-eleven-react-reagent-solo-client-reagent"></a>Step Eleven: React, Reagent, solo.client.reagent</h1>
<hr />
<ul>
  <li>dev-cards?</li>
</ul>
<hr />
<h1><a href="#step-12-chord-sente-solo-client-websockets" name="step-12-chord-sente-solo-client-websockets"></a>Step 12: chord, sente, solo.client.websockets</h1>
<hr />
<p><strong>TODO</strong>: full-duplex-async client-server communication</p>
<ul>
  <li>solo.websockets</li>
</ul>
<hr />
<h1><a href="#step-13-package-release-deploy" name="step-13-package-release-deploy"></a>Step 13: Package, Release, Deploy</h1>
<hr />
<p><strong>TODO</strong>: build and use a Web-App (WAR) that you can deploy to JBoss/Wildfly/Websphere to tweak your log4j configuration at runtime.</p>
<hr />
<h1><a href="#notes-todo" name="notes-todo"></a>Notes, TODO</h1>
<hr />
<ul>
  <li>
  <p>Step-four ist noch nicht ok, weil wir dort noch kein nREPL  haben. Wir können also nur Swank starten. In step-five können wir  dann nREPL einführen.</p></li>
  <li>
  <p>setup <code>master</code> branch</p></li>
  <li>
  <p>lein: code, run, test, deploy, release, codox</p></li>
  <li>
  <p>Gorilla REPL: introduce Gorilla REPL</p></li>
  <li>
  <p><a href="https://github.com/metosin/compojure-api">https://github.com/metosin/compojure-api</a></p></li>
</ul></div></div></div></body></html>